====== Function COPY-TREE ======

====Syntax====

**copy-tree** //tree// → //new-tree//

====Arguments and Values====

//tree// - a //[[CL:Glossary:tree]]//.

//new-tree// - a //[[CL:Glossary:tree]]//.

====Description====

Creates a //[[CL:Glossary:copy]]// of a //[[CL:Glossary:tree]]// of //[[CL:Glossary:conses]]//.

If //tree// is not a //[[CL:Glossary:cons]]//, it is returned; otherwise, the result is a new //[[CL:Glossary:cons]]// of the results of calling **[[CL:Functions:copy-tree]]** on the //[[CL:Glossary:car]]// and //[[CL:Glossary:cdr]]// of //tree//. In other words, all //[[CL:Glossary:conses]]// in the //[[CL:Glossary:tree]]// represented by //tree// are copied recursively, stopping only when non-//[[CL:Glossary:conses]]// are encountered.

**[[CL:Functions:copy-tree]]** does not preserve circularities and the sharing of substructure.

====Examples====

<blockquote> ([[CL:Macros:defparameter]] object (list (cons 1 "one") (cons 2 (list 'a 'b 'c)))) → ((1 . "one") (2 A B C)) ([[CL:Macros:defparameter]] object-too object) → ((1 . "one") (2 A B C)) ([[CL:Macros:defparameter]] copy-as-list (copy-list object)) ([[CL:Macros:defparameter]] copy-as-alist (copy-alist object)) ([[CL:Macros:defparameter]] copy-as-tree (copy-tree object)) (eq object object-too) → //[[CL:Glossary:true]]// (eq copy-as-tree object) → //[[CL:Glossary:false]]// (eql copy-as-tree object) → //[[CL:Glossary:false]]// (equal copy-as-tree object) → //[[CL:Glossary:true]]// ([[CL:Macros:setf]] (first (cdr (second object))) "a" (car (second object)) "two" (car object) '(one . 1)) → (ONE . 1) object → ((ONE . 1) ("two" "a" B C)) object-too → ((ONE . 1) ("two" "a" B C)) copy-as-list → ((1 . "one") ("two" "a" B C)) copy-as-alist → ((1 . "one") (2 "a" B C)) copy-as-tree → ((1 . "one") (2 A B C)) </blockquote>

====Side Effects====

None.

====Affected By====

None.

====Exceptional Situations====

None.

====See Also====

**[[CL:Functions:tree-equal]]**

====Notes====

None.

\issue{DOTTED-LIST-ARGUMENTS:CLARIFY}
