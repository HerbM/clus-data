====== Macro DO, DO* ======

====Syntax====

\DefmacWithValuesNewline do {\vtop{\hbox{\paren{\star{\VarInitStep}}} \hbox{\paren{end-test-form \starparam{result-form}}} \hbox{\starparam{declaration} \star{{tag ''\vert'' statement}}}}} {\starparam{result}}

\DefmacWithValuesNewline {do*} {\vtop{\hbox{\paren{\star{\VarInitStep}}} \hbox{\paren{end-test-form {\starparam{result-form}}}} \hbox{\starparam{declaration} \star{{tag ''\vert'' statement}}}}} {\starparam{result}}

====Arguments and Values====

//var// - a //[[CL:Glossary:symbol]]//.

//init-form// - a //[[CL:Glossary:form]]//.

//step-form// - a //[[CL:Glossary:form]]//.

//end-test-form// - a //[[CL:Glossary:form]]//.

//result-forms// - an //[[CL:Glossary:implicit progn]]//.

//declaration// - a \misc{declare} //[[CL:Glossary:expression]]//; \noeval.

//tag// - a //[[CL:Glossary:go tag]]//; \noeval.

//statement// - a //[[CL:Glossary:compound form]]//; \evalspecial.

//results// - if a **[[CL:Macros:return]]** or **[[CL:Macros:return-from]]** form is executed, the //[[CL:Glossary:values]]// passed from that //[[CL:Glossary:form]]//;

otherwise, the //[[CL:Glossary:values]]// returned by the //result-forms//.

====Description====

**[[CL:Macros:do]]** iterates over a group of //statements// while a test condition holds. **[[CL:Macros:do]]** accepts an arbitrary number of iteration //vars// which are bound within the iteration and stepped in parallel. An initial value may be supplied for each iteration variable by use of an //init-form//. //Step-forms// may be used to specify how the //vars// should be updated on succeeding iterations through the loop. //Step-forms// may be used both to generate successive values or to accumulate results. If the //end-test-form// condition is met prior to an execution of the body, the iteration terminates. //Tags// label //statements//.

**[[CL:Macros:do*]]** is exactly like **[[CL:Macros:do]]** except that the //[[CL:Glossary:bindings]]// and steppings of the //vars// are performed sequentially rather than in parallel.

Before the first iteration, all the //init-forms// are evaluated, and each //var// is bound to the value of its respective //init-form//, if supplied. This is a //[[CL:Glossary:binding]]//, not an assignment; when the loop terminates, the old values of those variables will be restored. For **[[CL:Macros:do]]**, all of the //init-forms// are evaluated before any //var// is bound. The //init-forms// can refer to the //[[CL:Glossary:bindings]]// of the //vars// visible before beginning execution of **[[CL:Macros:do]]**. For **[[CL:Macros:do*]]**, the first //init-form// is evaluated, then the first //var// is bound to that value, then the second //init-form// is evaluated, then the second //var// is bound, and so on; in general, the ''k''th //init-form// can refer to the new binding of the ''j''th //var// if ''j'' < ''k'', and otherwise to the old binding of the ''j''th //var//.

At the beginning of each iteration, after processing the variables, the //end-test-form// is evaluated. If the result is //[[CL:Glossary:false]]//, execution proceeds with the body of the **[[CL:Macros:do]]** (or **[[CL:Macros:do*]]**) form. If the result is //[[CL:Glossary:true]]//, the //result-forms// are evaluated in order as an //[[CL:Glossary:implicit progn]]//, and then **[[CL:Macros:do]]** or **[[CL:Macros:do*]]** returns.

At the beginning of each iteration other than the first, //vars// are updated as follows. All the //step-forms//, if supplied, are evaluated, from left to right, and the resulting values are assigned to the respective //vars//. Any //var// that has no associated //step-form// is not assigned to. For **[[CL:Macros:do]]**, all the //step-forms// are evaluated before any //var// is updated; the assignment of values to //vars// is done in parallel, as if by **[[CL:Macros:psetq]]**. Because all of the //step-forms// are evaluated before any of the //vars// are altered, a //step-form// when evaluated always has access to the old values of all the //vars//, even if other //step-forms// precede it. For **[[CL:Macros:do*]]**, the first //step-form// is evaluated, then the value is assigned to the first //var//, then the second //step-form// is evaluated, then the value is assigned to the second //var//, and so on; the assignment of values to variables is done sequentially, as if by \specref{setq}. For either **[[CL:Macros:do]]** or **[[CL:Macros:do*]]**, after the //vars// have been updated, the //end-test-form// is evaluated as described above, and the iteration continues.

The remainder of the **[[CL:Macros:do]]** (or **[[CL:Macros:do*]]**) form constitutes an //[[CL:Glossary:implicit tagbody]]//. //Tags// may appear within the body of a **[[CL:Macros:do]]** loop for use by \specref{go} statements appearing in the body (but such \specref{go} statements may not appear in the variable specifiers, the //end-test-form//, or the //result-forms//). When the end of a **[[CL:Macros:do]]** body is reached, the next iteration cycle (beginning with the evaluation of //step-forms//) occurs.

An //[[CL:Glossary:implicit block]]// named **[[CL:Constant Variables:nil]]** surrounds the entire **[[CL:Macros:do]]** (or **[[CL:Macros:do*]]**) form. A **[[CL:Macros:return]]** statement may be used at any point to exit the loop immediately.

//Init-form// is an initial value for the //var// with which it is associated. If //init-form// is omitted, the initial value of //var// is **[[CL:Constant Variables:nil]]**. If a //declaration// is supplied for a //var//, //init-form// must be consistent with the //declaration//.

//Declarations// can appear at the beginning of a **[[CL:Macros:do]]** (or **[[CL:Macros:do*]]**) body. They apply to code in the **[[CL:Macros:do]]** (or **[[CL:Macros:do*]]**) body, to the //[[CL:Glossary:bindings]]// of the **[[CL:Macros:do]]** (or **[[CL:Macros:do*]]**) //vars//,

to the //step-forms//, to the //end-test-form//, and to the //result-forms//.

====Examples====

<blockquote> (do ((temp-one 1 (1+ temp-one)) (temp-two 0 (1- temp-two))) ((> (- temp-one temp-two) 5) temp-one)) → 4

(do ((temp-one 1 (1+ temp-one)) (temp-two 0 (1+ temp-one))) ((= 3 temp-two) temp-one)) → 3

(do* ((temp-one 1 (1+ temp-one)) (temp-two 0 (1+ temp-one))) ((= 3 temp-two) temp-one)) → 2

(do ((j 0 (+ j 1))) (nil) ;Do forever. (format t "~ (let ((item (read))) (if (null item) (return) ;Process items until NIL seen. (format t "~&Output ~D: ~S" j item))))
▷ Input 0: \IN{banana}
▷ Output 0: BANANA
▷ Input 1: \IN{(57 boxes)}
▷ Output 1: (57 BOXES)
▷ Input 2: \IN{NIL} → NIL

([[CL:Macros:defparameter]] a-vector (vector 1 nil 3 nil)) (do ((i 0 (+ i 1)) ;Sets every null element of a-vector to zero. (n (array-dimension a-vector 0))) ((= i n)) (when (null (aref a-vector i)) ([[CL:Macros:setf]] (aref a-vector i) 0))) → NIL a-vector → #(1 0 3 0) </blockquote>

<blockquote> (do ((x e (cdr x)) (oldx x x)) ((null x)) body) </blockquote> is an example of parallel assignment to index variables. On the first iteration, the value of ''oldx'' is whatever value ''x'' had before the **[[CL:Macros:do]]** was entered. On succeeding iterations, ''oldx'' contains the value that ''x'' had on the previous iteration.

<blockquote> (do ((x foo (cdr x)) (y bar (cdr y)) (z '() (cons (f (car x) (car y)) z))) ((or (null x) (null y)) (nreverse z))) </blockquote> does the same thing as ''(mapcar #'f foo bar)''. The step computation for ''z'' is an example of the fact that variables are stepped in parallel. Also, the body of the loop is empty.

<blockquote> (defun list-reverse (list) (do ((x list (cdr x)) (y '() (cons (car x) y))) ((endp x) y))) </blockquote>

As an example of nested iterations, consider a data structure that is a //[[CL:Glossary:list]]// of //[[CL:Glossary:conses]]//. The //[[CL:Glossary:car]]// of each //[[CL:Glossary:cons]]// is a //[[CL:Glossary:list]]// of //[[CL:Glossary:symbols]]//, and the //[[CL:Glossary:cdr]]// of each //[[CL:Glossary:cons]]// is a //[[CL:Glossary:list]]// of equal length containing corresponding values. Such a data structure is similar to an association list, but is divided into "frames"; the overall structure resembles a rib-cage. A lookup function on such a data structure might be:

<blockquote> (defun ribcage-lookup (sym ribcage) (do ((r ribcage (cdr r))) ((null r) nil) (do ((s (caar r) (cdr s)) (v (cdar r) (cdr v))) ((null s)) (when (eq (car s) sym) (return-from ribcage-lookup (car v)))))) → RIBCAGE-LOOKUP </blockquote>

====Affected By====

None.

====Exceptional Situations====

None.

====See Also====

other iteration functions (**[[CL:Macros:dolist]]**, **[[CL:Macros:dotimes]]**, and **[[CL:Macros:loop]]**) and more primitive functionality (\specref{tagbody}, \specref{go}, \specref{block}, **[[CL:Macros:return]]**, \specref{let}, and \specref{[[CL:Macros:defparameter]]})

====Notes====

If //end-test-form// is **[[CL:Constant Variables:nil]]**, the test will never succeed. This provides an idiom for "do forever": the body of the **[[CL:Macros:do]]** or **[[CL:Macros:do*]]** is executed repeatedly. The infinite loop can be terminated by the use of **[[CL:Macros:return]]**, \specref{return-from}, \specref{go} to an outer level, or \specref{throw}.

A **[[CL:Macros:do]]** //[[CL:Glossary:form]]// may be explained in terms of the more primitive //[[CL:Glossary:forms]]// \specref{block}, **[[CL:Macros:return]]**, \specref{let}, **[[CL:Macros:loop]]**, \specref{tagbody}, and **[[CL:Macros:p[[CL:Macros:defparameter]]]]** as follows:

<blockquote> (block nil (let ((var1 init1) (var2 init2) ... (varn initn)) ''declarations'' (loop (when end-test (return (progn . result))) (tagbody . tagbody) (p[[CL:Macros:defparameter]] var1 step1 var2 step2 ... varn stepn)))) </blockquote>

**[[CL:Macros:do*]]** is similar, except that \specref{let*} and \specref{setq} replace the \specref{let} and **[[CL:Macros:psetq]]**, respectively.

\issue{DECLS-AND-DOC} \issue{VARIABLE-LIST-ASYMMETRY:SYMMETRIZE}
