====== Accessor LOGICAL-PATHNAME-TRANSLATIONS ======

====Syntax====

**logical-pathname-translations** //host// → //translations// (**setf** (**logical-pathname-translations** //host//) //new-translations//)

====Arguments and Values====

//host//--a //[[CL:Glossary:logical host designator]]//.

//translations//, //new-translations// - a //[[CL:Glossary:list]]//.

====Description====

Returns the host's //[[CL:Glossary:list]]// of translations. Each translation is a //[[CL:Glossary:list]]// of at least two elements: ''from-wildcard'' and ''to-wildcard''. Any additional elements are //[[CL:Glossary:implementation-defined]]//. ''From-wildcard'' is a //[[CL:Glossary:logical pathname]]// whose host is //host//. ''To-wildcard'' is a //[[CL:Glossary:pathname]]//. \reviewer{Laddaga: Can this be a logical pathname?}

''(setf (logical-pathname-translations //host//) ''translations'')'' sets a //[[CL:Glossary:logical pathname]]// host's //[[CL:Glossary:list]]// of ''translations''. If //host// is a //[[CL:Glossary:string]]// that has not been previously used as a //[[CL:Glossary:logical pathname]]// host, a new //[[CL:Glossary:logical pathname]]// host is defined; otherwise an existing host's translations are replaced. //[[CL:Glossary:logical pathname]]// host names are compared with **[[CL:Functions:string-equal]]**.

When setting the translations list, each ''from-wildcard'' can be a //[[CL:Glossary:logical pathname]]// whose host is //host// or a //[[CL:Glossary:logical pathname]]// namestring parseable by ''(parse-namestring //[[CL:Glossary:string]]// ''host'')'', where ''host'' represents the appropriate //[[CL:Glossary:object]]// as defined by **[[CL:Functions:parse-namestring]]**. Each ''to-wildcard'' can be anything coercible to a //[[CL:Glossary:pathname]]// by ''(pathname ''to-wildcard'')''. If ''to-wildcard'' coerces to a //[[CL:Glossary:logical pathname]]//, **[[CL:Functions:translate-logical-pathname]]** will perform repeated translation steps when it uses it.

//host// is either the host component of a //[[CL:Glossary:logical pathname]]// or a //[[CL:Glossary:string]]// that has been defined as a //[[CL:Glossary:logical pathname]]// host name by **[[CL:Macros:setf]]** of **[[CL:Functions:logical-pathname-translations]]**.

====Examples====

\reviewer{Laddaga: Shouldn't there be some ''*.*'''s in the list of translations for ''PROG'' below?}

<blockquote> ;;;A very simple example of setting up a logical pathname host. No ;;;translations are necessary to get around file system restrictions, so ;;;all that is necessary is to specify the root of the physical directory ;;;tree that contains the logical file system. ;;;The namestring syntax on the right-hand side is implementation-dependent. ([[CL:Macros:setf]] (logical-pathname-translations "foo") '(("**;*.*.*" "MY-LISPM:>library>foo>**>"))) \smallbreak ;;;Sample use of that logical pathname. The return value ;;;is implementation-dependent. (translate-logical-pathname "foo:bar;baz;mum.quux.3") → #P"MY-LISPM:>library>foo>bar>baz>mum.quux.3" \medbreak ;;;A more complex example, dividing the files among two file servers ;;;and several different directories. This Unix doesn't support ;;;:WILD-INFERIORS in the directory, so each directory level must ;;;be translated individually. No file name or type translations ;;;are required except for .MAIL to .MBX. ;;;The namestring syntax on the right-hand side is implementation-dependent. ([[CL:Macros:setf]] (logical-pathname-translations "prog") '(("RELEASED;*.*.*" "MY-UNIX:/sys/bin/my-prog/") ("RELEASED;*;*.*.*" "MY-UNIX:/sys/bin/my-prog/*/") ("EXPERIMENTAL;*.*.*" "MY-UNIX:/usr/Joe/development/prog/") ("EXPERIMENTAL;DOCUMENTATION;*.*.*" "MY-VAX:SYS''DISK:[JOE.DOC]") ("EXPERIMENTAL;*;*.*.*" "MY-UNIX:/usr/Joe/development/prog/*/") ("MAIL;**;*.MAIL" "MY-VAX:SYS''DISK:[JOE.MAIL.PROG...]*.MBX"))) \smallbreak ;;;Sample use of that logical pathname. The return value ;;;is implementation-dependent. (translate-logical-pathname "prog:mail;save;ideas.mail.3") → #P"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3" \medbreak ;;;Example translations for a program that uses three files main.lisp, ;;;auxiliary.lisp, and documentation.lisp. These translations might be ;;;supplied by a software supplier as examples. \smallbreak ;;;For Unix with long file names ([[CL:Macros:setf]] (logical-pathname-translations "prog") '(("CODE;*.*.*" "/lib/prog/"))) \smallbreak ;;;Sample use of that logical pathname. The return value ;;;is implementation-dependent. (translate-logical-pathname "prog:code;documentation.lisp") → #P"/lib/prog/documentation.lisp" \smallbreak ;;;For Unix with 14-character file names, using .lisp as the type ([[CL:Macros:setf]] (logical-pathname-translations "prog") '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*") ("CODE;*.*.*" "/lib/prog/")))

;;;Sample use of that logical pathname. The return value ;;;is implementation-dependent. (translate-logical-pathname "prog:code;documentation.lisp") → #P"/lib/prog/docum.lisp" \medbreak ;;;For Unix with 14-character file names, using .l as the type ;;;The second translation shortens the compiled file type to .b ([[CL:Macros:setf]] (logical-pathname-translations "prog") `(("**;*.LISP.*" ,(logical-pathname "PROG:**;*.L.*")) (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*")) ,(logical-pathname "PROG:**;*.B.*")) ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*") ("CODE;*.*.*" "/lib/prog/"))) \smallbreak ;;;Sample use of that logical pathname. The return value ;;;is implementation-dependent. (translate-logical-pathname "prog:code;documentation.lisp") → #P"/lib/prog/documentatio.l" \medbreak ;;;For a Cray with 6 character names and no directories, types, or versions. ([[CL:Macros:setf]] (logical-pathname-translations "prog") (let ((l '(("MAIN" "PGMN") ("AUXILIARY" "PGAUX") ("DOCUMENTATION" "PGDOC"))) (logpath (logical-pathname "prog:code;")) (phypath (pathname "XXX"))) (append ;; Translations for source files (mapcar #'(lambda (x) (let ((log (first x)) (phy (second x))) (list (make-pathname :name log :type "LISP" :version :wild :defaults logpath) (make-pathname :name phy :defaults phypath)))) l) ;; Translations for compiled files (mapcar #'(lambda (x) (let* ((log (first x)) (phy (second x)) (com (compile-file-pathname (make-pathname :name log :type "LISP" :version :wild :defaults logpath)))) ([[CL:Macros:defparameter]] phy (concatenate 'string phy "B")) (list com (make-pathname :name phy :defaults phypath)))) l))))

;;;Sample use of that logical pathname. The return value ;;;is implementation-dependent. (translate-logical-pathname "prog:code;documentation.lisp") → #P"PGDOC" </blockquote>

====Affected By====

None.

====Exceptional Situations====

If //host// is incorrectly supplied, an error of type **[[CL:Types:type-error]]** is signaled.

====See Also====

**[[CL:Types:logical-pathname]]**, {\secref\PathnamesAsFilenames}

====Notes====

Implementations can define additional //[[CL:Glossary:functions]]// that operate on //[[CL:Glossary:logical pathname]]// hosts, for example to specify additional translation rules or options.


\issue{PATHNAME-LOGICAL:ADD} \issue{FILE-OPEN-ERROR:SIGNAL-FILE-ERROR}
