====== Function MAPC, MAPCAR, MAPCAN, MAPL, MAPLIST, MAPCON ======

====Syntax====

**mapc ** //function ''&rest'' lists''+''// → //list-1// **mapcar ** //function ''&rest'' lists''+''// → //result-list// **mapcan ** //function ''&rest'' lists''+''// → //concatenated-results// **mapl ** //function ''&rest'' lists''+''// → //list-1// **maplist** //function ''&rest'' lists''+''// → //result-list// **mapcon ** //function ''&rest'' lists''+''// → //concatenated-results//

====Arguments and Values====

//function// - a //[[CL:Glossary:designator]]// for a //[[CL:Glossary:function]]// that must take as many //[[CL:Glossary:arguments]]// as there are //lists//.

//list// - a //[[CL:Glossary:proper list]]//.

//list-1// - the first //list// (which must be a //[[CL:Glossary:proper list]]//).

//result-list// - a //[[CL:Glossary:list]]//.

//concatenated-results// - a //[[CL:Glossary:list]]//.

====Description====

The mapping operation involves applying //function// to successive sets of arguments in which one argument is obtained from each //[[CL:Glossary:sequence]]//. Except for **[[CL:Functions:mapc]]** and **[[CL:Functions:mapl]]**, the result contains the results returned by //function//. In the cases of **[[CL:Functions:mapc]]** and **[[CL:Functions:mapl]]**, the resulting //[[CL:Glossary:sequence]]// is //list//.

//function// is called first on all the elements with index ''0'', then on all those with index ''1'', and so on. //result-type// specifies the //[[CL:Glossary:type]]// of the resulting //[[CL:Glossary:sequence]]//.

If //function// is a //[[CL:Glossary:symbol]]//, it is **[[CL:Functions:coerce]]**d to a //[[CL:Glossary:function]]// as if by **[[CL:Functions:symbol-function]]**.

**[[CL:Functions:mapcar]]** operates on successive //[[CL:Glossary:element|elements]]// of the //lists//. //function// is applied to the first //[[CL:Glossary:element]]// of each //list//, then to the second //[[CL:Glossary:element]]// of each //list//, and so on. The iteration terminates when the shortest //list// runs out, and excess elements in other lists are ignored. The value returned by **[[CL:Functions:mapcar]]** is a //[[CL:Glossary:list]]// of the results of successive calls to //function//.

**[[CL:Functions:mapc]]** is like **[[CL:Functions:mapcar]]** except that the results of applying //function// are not accumulated. The //list// argument is returned.

**[[CL:Functions:maplist]]** is like **[[CL:Functions:mapcar]]** except that //function// is applied to successive sublists of the //lists//. //function// is first applied to the //lists// themselves, and then to the //[[CL:Glossary:cdr]]// of each //list//, and then to the //[[CL:Glossary:cdr]]// of the //[[CL:Glossary:cdr]]// of each //list//, and so on.

**[[CL:Functions:mapl]]** is like **[[CL:Functions:maplist]]** except that the results of applying //function// are not accumulated; //list-1// is returned.


**[[CL:Functions:mapcan]]** and **[[CL:Functions:mapcon]]** are like **[[CL:Functions:mapcar]]** and **[[CL:Functions:maplist]]** respectively, except that the results of applying //function// are combined into a //[[CL:Glossary:list]]// by the use of **[[CL:Functions:nconc]]** rather than **[[CL:Functions:list]]**. That is,

<blockquote> (mapcon f x1 ... xn) ≡ (apply #'nconc (maplist f x1 ... xn)) </blockquote> and similarly for the relationship between **[[CL:Functions:mapcan]]** and **[[CL:Functions:mapcar]]**.

====Examples====

<blockquote> (mapcar #'car '((1 a) (2 b) (3 c))) → (1 2 3) (mapcar #'abs '(3 -4 2 -5 -6)) → (3 4 2 5 6) (mapcar #'cons '(a b c) '(1 2 3)) → ((A . 1) (B . 2) (C . 3))

(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) → ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) (maplist #'(lambda (x) (cons 'foo x)) '(a b c d)) → ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D)) (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c)) → (0 0 1 0 1 1 1) ;An entry is 1 if the corresponding element of the input ; list was the last instance of that element in the input list.

([[CL:Macros:defparameter]] dummy nil) → NIL (mapc #'(lambda (&rest x) ([[CL:Macros:defparameter]] dummy (append dummy x))) '(1 2 3 4) '(a b c d e) '(x y z)) → (1 2 3 4) dummy → (1 A X 2 B Y 3 C Z)

([[CL:Macros:defparameter]] dummy nil) → NIL (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) → (1 2 3 4) dummy → ((4) (3 4) (2 3 4) (1 2 3 4))

(mapcan #'(lambda (x y) (if (null x) nil (list x y))) '(nil nil nil d e) '(1 2 3 4 5 6)) → (D 4 E 5) (mapcan #'(lambda (x) (and (numberp x) (list x))) '(a 1 b c 3 4 d 5)) → (1 3 4 5) </blockquote> In this case the function serves as a filter; this is a standard Lisp idiom using **[[CL:Functions:mapcan]]**.

<blockquote> (mapcon #'list '(1 2 3 4)) → ((1 2 3 4) (2 3 4) (3 4) (4)) </blockquote>

====Affected By====

None.

====Exceptional Situations====

Should be prepared to signal an error of type type-error if any //list// is not a //[[CL:Glossary:proper list]]//.

====See Also====

**[[CL:Macros:dolist]]**, **[[CL:Functions:map]]**,

{\secref\TraversalRules}

====Notes====

None.

\issue{DOTTED-LIST-ARGUMENTS:CLARIFY} \issue{FUNCTION-TYPE:X3J13-MARCH-88} \issue{MAPPING-DESTRUCTIVE-INTERACTION:EXPLICITLY-VAGUE}
