====== Function LDIFF, TAILP ======

====Syntax====

**ldiff** //list object// → //result-list// **tailp** //object list// → //generalized-boolean//

====Arguments and Values====

//list// - a //[[CL:Glossary:list]]//,

which might be a //[[CL:Glossary:dotted list]]//.

//object// - an //[[CL:Glossary:object]]//.

//result-list// - a //[[CL:Glossary:list]]//.

//generalized-boolean// - a //[[CL:Glossary:generalized boolean]]//.

====Description====

If //object// is the //[[CL:Glossary:same]]// as some //[[CL:Glossary:tail]]// of //list//, **[[CL:Functions:tailp]]** returns //[[CL:Glossary:true]]//; otherwise, it returns //[[CL:Glossary:false]]//.

If //object// is the //[[CL:Glossary:same]]// as some //[[CL:Glossary:tail]]// of //list//, **[[CL:Functions:ldiff]]** returns a //[[CL:Glossary:fresh]]// //[[CL:Glossary:list]]// of the //[[CL:Glossary:element|elements]]// of //[[CL:Glossary:list]]// that precede **[[CL:Functions:object]]** in the //[[CL:Glossary:list structure]]// of //list//; otherwise, it returns a //[[CL:Glossary:copy]]// of //list//.

====Examples====

<blockquote> (let ((lists '#((a b c) (a b c . d)))) (dotimes (i (length lists)) () (let ((list (aref lists i))) (format t "~2&list=~S ~21T(tailp object list)~ ~44T(ldiff list object)~ (let ((objects (vector list (cddr list) (copy-list (cddr list)) '(f g h) '() 'd 'x))) (dotimes (j (length objects)) () (let ((object (aref objects j))) (format t "~& object=~S ~21T~S ~44T~S" object (tailp object list) (ldiff list object))))))))
▷
▷ list=(A B C) (tailp object list) (ldiff list object)
▷ object=(A B C) T NIL
▷ object=(C) T (A B)
▷ object=(C) NIL (A B C)
▷ object=(F G H) NIL (A B C)
▷ object=NIL T (A B C)
▷ object=D NIL (A B C)
▷ object=X NIL (A B C)
▷
▷ list=(A B C . D) (tailp object list) (ldiff list object)
▷ object=(A B C . D) T NIL
▷ object=(C . D) T (A B)
▷ object=(C . D) NIL (A B C . D)
▷ object=(F G H) NIL (A B C . D)
▷ object=NIL NIL (A B C . D)
▷ object=D T (A B C)
▷ object=X NIL (A B C . D) → NIL </blockquote>

====Side Effects====

Neither **[[CL:Functions:ldiff]]** nor **[[CL:Functions:tailp]]** modifies either of its //[[CL:Glossary:arguments]]//.

====Affected By====

None.

====Exceptional Situations====

Should be prepared to signal an error of type type-error if //list// is not a //[[CL:Glossary:proper list]]// or a //[[CL:Glossary:dotted list]]//.

====See Also====

**[[CL:Functions:set-difference]]**

====Notes====

If the //list// is a //[[CL:Glossary:circular list]]//, **[[CL:Functions:tailp]]** will reliably //[[CL:Glossary:yield]]// a //[[CL:Glossary:value]]// only if the given //object// is in fact a //[[CL:Glossary:tail]]// of //list//. Otherwise, the consequences are unspecified: a given //[[CL:Glossary:implementation]]// which detects the circularity must return //[[CL:Glossary:false]]//, but since an //[[CL:Glossary:implementation]]// is not obliged to detect such a //[[CL:Glossary:situation]]//, **[[CL:Functions:tailp]]** might just loop indefinitely without returning in that case.

**[[CL:Functions:tailp]]** could be defined as follows:

<blockquote> (defun tailp (object list) (do ((list list (cdr list))) ((atom list) (eql list object)) (if (eql object list) (return t)))) </blockquote>

and **[[CL:Functions:ldiff]]** could be defined by:

<blockquote> (defun ldiff (list object) (do ((list list (cdr list)) (r '() (cons (car list) r))) ((atom list) (if (eql list object) (nreverse r) (nreconc r list))) (when (eql object list) (return (nreverse r))))) </blockquote>

\issue{DOTTED-LIST-ARGUMENTS:CLARIFY} \issue{TAILP-NIL:T} \issue{TAILP-NIL:T} \issue{DOTTED-LIST-ARGUMENTS:CLARIFY} \issue{TAILP-NIL:T} \issue{DOTTED-LIST-ARGUMENTS:CLARIFY}
