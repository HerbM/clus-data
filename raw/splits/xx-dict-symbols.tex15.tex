====== Accessor GET ======

====Syntax====

**get {symbol indicator** //\opt} default// → //value// (**setf** (**get {symbol indicator** //\opt} default//) //new-value//)

====Arguments and Values====

//symbol// - a //[[CL:Glossary:symbol]]//.

//indicator// - an //[[CL:Glossary:object]]//.

//default// - an //[[CL:Glossary:object]]//. The default is **[[CL:Constant Variables:nil]]**.

//value// - if the indicated property exists, the //[[CL:Glossary:object]]// that is its //[[CL:Glossary:value]]//; otherwise, the specified //default//.

//new-value// - an //[[CL:Glossary:object]]//.

====Description====

**[[CL:Functions:get]]** finds a //[[CL:Glossary:property]]// on the //[[CL:Glossary:property list]]// of //symbol// whose //[[CL:Glossary:property indicator]]// is //[[CL:Glossary:identical]]// to //indicator//, and returns its corresponding //[[CL:Glossary:property value]]//.

If there are multiple //[[CL:Glossary:properties]]// with that //[[CL:Glossary:property indicator]]//, **[[CL:Functions:get]]** uses the first such //[[CL:Glossary:property]]//.

If there is no //[[CL:Glossary:property]]// with that //[[CL:Glossary:property indicator]]//, //default// is returned.

**[[CL:Macros:setf]]** of **[[CL:Functions:get]]** may be used to associate a new //[[CL:Glossary:object]]// with an existing indicator already on the //symbol//'s //[[CL:Glossary:property list]]//, or to create a new assocation if none exists.

If there are multiple //[[CL:Glossary:properties]]// with that //[[CL:Glossary:property indicator]]//, **[[CL:Macros:setf]]** of **[[CL:Functions:get]]** associates the //new-value// with the first such //[[CL:Glossary:property]]//.

When a **[[CL:Functions:get]]** //[[CL:Glossary:form]]// is used as a **[[CL:Macros:setf]]** //place//, any //default// which is supplied is evaluated according to normal left-to-right evaluation rules, but its //[[CL:Glossary:value]]// is ignored.

====Examples====

<blockquote> (defun make-person (first-name last-name) (let ((person (gensym "PERSON"))) ([[CL:Macros:setf]] (get person 'first-name) first-name) ([[CL:Macros:setf]] (get person 'last-name) last-name) person)) → MAKE-PERSON (defvar *john* (make-person "John" "Dow")) → *JOHN* *john* → #:PERSON4603 (defvar *sally* (make-person "Sally" "Jones")) → *SALLY* (get *john* 'first-name) → "John" (get *sally* 'last-name) → "Jones" (defun marry (man woman married-name) ([[CL:Macros:setf]] (get man 'wife) woman) ([[CL:Macros:setf]] (get woman 'husband) man) ([[CL:Macros:setf]] (get man 'last-name) married-name) ([[CL:Macros:setf]] (get woman 'last-name) married-name) married-name) → MARRY (marry *john* *sally* "Dow-Jones") → "Dow-Jones" (get *john* 'last-name) → "Dow-Jones" (get (get *john* 'wife) 'first-name) → "Sally" (symbol-plist *john*) → (WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John") (defmacro age (person &optional (default ''thirty-something)) `(get ,person 'age ,default)) → AGE (age *john*) → THIRTY-SOMETHING (age *john* 20) → 20 ([[CL:Macros:setf]] (age *john*) 25) → 25 (age *john*) → 25 (age *john* 20) → 25 </blockquote>

====Side Effects====

None.

====Affected By====

None.

====Exceptional Situations====

Should signal an error of type type-error if //symbol// is not a //[[CL:Glossary:symbol]]//.

====See Also====

**[[CL:Functions:getf]]**, **[[CL:Functions:symbol-plist]]**, **[[CL:Functions:remprop]]**

====Notes====

<blockquote> (get x y) ≡ (getf (symbol-plist x) y) </blockquote>

//[[CL:Glossary:Numbers]]// and //[[CL:Glossary:characters]]// are not recommended for use as //indicators// in portable code since **[[CL:Functions:get]]** tests with **[[CL:Functions:eq]]** rather than **[[CL:Functions:eql]]**, and consequently the effect of using such //indicators// is //[[CL:Glossary:implementation-dependent]]//.

There is no way using **[[CL:Functions:get]]** to distinguish an absent property from one whose value is //default//. However, see **[[CL:Functions:get-properties]]**.




\issue{PLIST-DUPLICATES:ALLOW} \issue{PLIST-DUPLICATES:ALLOW} \issue{SETF-GET-DEFAULT:EVALUATED-BUT-IGNORED}
