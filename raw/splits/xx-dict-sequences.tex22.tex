\begincom{remove, remove-if, remove-if-not, delete, delete-if, delete-if-not}\ftype{Function}

====Syntax====

\DefunWithValues remove {item sequence ''&key'' from-end test test-not start end count key} {result-sequence}

\DefunWithValues remove-if {test sequence ''&key'' from-end start end count key} {result-sequence}

\DefunWithValues remove-if-not {test sequence ''&key'' from-end start end count key} {result-sequence}

\DefunWithValues delete {item sequence ''&key'' from-end test test-not start end count key} {result-sequence}

\DefunWithValues delete-if {test sequence ''&key'' from-end start end count key} {result-sequence}

\DefunWithValues delete-if-not {test sequence ''&key'' from-end start end count key} {result-sequence}

====Arguments and Values====

//item// - an //[[CL:Glossary:object]]//.

//sequence// - a //[[CL:Glossary:proper sequence]]//.

//test// - a //[[CL:Glossary:designator]]// for a //[[CL:Glossary:function]]// of one //[[CL:Glossary:argument]]// that returns a //[[CL:Glossary:generalized boolean]]//.

//from-end// - a //[[CL:Glossary:generalized boolean]]//. The default is //[[CL:Glossary:false]]//.

//test// - a //[[CL:Glossary:designator]]// for a //[[CL:Glossary:function]]// of two //[[CL:Glossary:arguments]]// that returns a //[[CL:Glossary:generalized boolean]]//.

//test-not// - a //[[CL:Glossary:designator]]// for a //[[CL:Glossary:function]]// of two //[[CL:Glossary:arguments]]// that returns a //[[CL:Glossary:generalized boolean]]//.

//start//, //end// - //[[CL:Glossary:bounding index designators]]// of //sequence//. \Defaults{//start// and //end//}{''0'' and **[[CL:Constant Variables:nil]]**}

//count// - an //[[CL:Glossary:integer]]// or **[[CL:Constant Variables:nil]]**.

The default is **[[CL:Constant Variables:nil]]**.

//key// - a //[[CL:Glossary:designator]]// for a //[[CL:Glossary:function]]// of one argument, or **[[CL:Constant Variables:nil]]**.

//result-sequence// - a //[[CL:Glossary:sequence]]//.

====Description====

**[[CL:Functions:remove]]**, **[[CL:Functions:remove-if]]**, and **[[CL:Functions:remove-if-not]]** return a //sequence// from which the elements that //[[CL:Glossary:satisfy the test]]// have been removed.

**[[CL:Functions:delete]]**, **[[CL:Functions:delete-if]]**, and **[[CL:Functions:delete-if-not]]** are like **[[CL:Functions:remove]]**, **[[CL:Functions:remove-if]]**, and **[[CL:Functions:remove-if-not]]** respectively, but they may modify //sequence//.

If //sequence// is a //[[CL:Glossary:vector]]//, the result is a //[[CL:Glossary:vector]]// that has the same //[[CL:Glossary:actual array element type]]// as //sequence//.

If //sequence// is a //[[CL:Glossary:list]]//, the result is a //[[CL:Glossary:list]]//.

Supplying a //from-end// of //[[CL:Glossary:true]]// matters only when the //count// is provided; in that case only the rightmost //count// elements //[[CL:Glossary:satisfying the test]]// are deleted.

//Count//, if supplied, limits the number of elements removed or deleted; if more than //count// elements //[[CL:Glossary:satisfy the test]]//, then of these elements only the leftmost or rightmost, depending on //from-end//, are deleted or removed, as many as specified by //count//.

If //count// is supplied and negative, the behavior is as if zero had been supplied instead.

If //count// is **[[CL:Constant Variables:nil]]**, all matching items are affected.

For all these functions, elements not removed or deleted occur in the same order in the result as they did in //sequence//.

**[[CL:Functions:remove]]**, **[[CL:Functions:remove-if]]**, **[[CL:Functions:remove-if-not]]** return a //[[CL:Glossary:sequence]]// of the same //[[CL:Glossary:type]]// as //sequence// that has the same elements except that those in the subsequence //[[CL:Glossary:bounded]]// by //start// and //end// and //[[CL:Glossary:satisfying the test]]// have been removed. This is a non-destructive operation. If any elements need to be removed, the result will be a copy. The result of **[[CL:Functions:remove]]** may share with //sequence//; the result may be //[[CL:Glossary:identical]]// to the input //sequence// if no elements need to be removed.

**[[CL:Functions:delete]]**, **[[CL:Functions:delete-if]]**, and **[[CL:Functions:delete-if-not]]** return a //[[CL:Glossary:sequence]]// of the same //[[CL:Glossary:type]]// as //sequence// that has the same elements except that those in the subsequence //[[CL:Glossary:bounded]]// by //start// and //end// and //[[CL:Glossary:satisfying the test]]// have been deleted. //Sequence// may be destroyed and used to construct the result; however, the result might or might not be //[[CL:Glossary:identical]]// to //sequence//.

**[[CL:Functions:delete]]**, when //sequence// is a //[[CL:Glossary:list]]//, is permitted to **[[CL:Macros:setf]]** any part, **[[CL:Functions:car]]** or **[[CL:Functions:cdr]]**, of the top-level list structure in that //sequence//. When //sequence// is a //[[CL:Glossary:vector]]//, **[[CL:Functions:delete]]** is permitted to change the dimensions of the //[[CL:Glossary:vector]]// and to slide its elements into new positions without permuting them to produce the resulting //[[CL:Glossary:vector]]//.

**[[CL:Functions:delete-if]]** is constrained to behave exactly as follows:

<blockquote> (delete nil ''sequence'' :test #'(lambda (ignore ''item'') (funcall ''test'' ''item'')) ...) </blockquote>


====Examples==== <blockquote> (remove 4 '(1 3 4 5 9)) → (1 3 5 9) (remove 4 '(1 2 4 1 3 4 5)) → (1 2 1 3 5) (remove 4 '(1 2 4 1 3 4 5) :count 1) → (1 2 1 3 4 5) (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) → (1 2 4 1 3 5) (remove 3 '(1 2 4 1 3 4 5) :test #'>) → (4 3 4 5) ([[CL:Macros:defparameter]] lst '(list of four elements)) → (LIST OF FOUR ELEMENTS) ([[CL:Macros:defparameter]] lst2 (copy-seq lst)) → (LIST OF FOUR ELEMENTS) ([[CL:Macros:defparameter]] lst3 (delete 'four lst)) → (LIST OF ELEMENTS) (equal lst lst2) → //[[CL:Glossary:false]]// (remove-if #'oddp '(1 2 4 1 3 4 5)) → (2 4 4) (remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) → (1 2 4 1 3 5) (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t) → (1 2 3 4 5 6 8) ([[CL:Macros:defparameter]] tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5) (delete 4 tester) → (1 2 1 3 5) ([[CL:Macros:defparameter]] tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5) (delete 4 tester :count 1) → (1 2 1 3 4 5) ([[CL:Macros:defparameter]] tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5) (delete 4 tester :count 1 :from-end t) → (1 2 4 1 3 5) ([[CL:Macros:defparameter]] tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5) (delete 3 tester :test #'>) → (4 3 4 5) ([[CL:Macros:defparameter]] tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5) (delete-if #'oddp tester) → (2 4 4) ([[CL:Macros:defparameter]] tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5) (delete-if #'evenp tester :count 1 :from-end t) → (1 2 4 1 3 5) ([[CL:Macros:defparameter]] tester (list 1 2 3 4 5 6)) → (1 2 3 4 5 6) (delete-if #'evenp tester) → (1 3 5) tester → //[[CL:Glossary:implementation-dependent]]// </blockquote>

<blockquote> ([[CL:Macros:defparameter]] foo (list 'a 'b 'c)) → (A B C) ([[CL:Macros:defparameter]] bar (cdr foo)) → (B C) ([[CL:Macros:defparameter]] foo (delete 'b foo)) → (A C) bar → ((C)) or ... (eq (cdr foo) (car bar)) → T or ... </blockquote>

====Side Effects====

For **[[CL:Functions:delete]]**, **[[CL:Functions:delete-if]]**, and **[[CL:Functions:delete-if-not]]**, //sequence// may be destroyed and used to construct the result.

====Affected By====

None.

====Exceptional Situations====

Should be prepared to signal an error of type type-error if //sequence// is not a //[[CL:Glossary:proper sequence]]//.

====See Also====

{\secref\ConstantModification},

{\secref\TraversalRules}

====Notes====

If //sequence// is a //[[CL:Glossary:vector]]//, the result might or might not be simple, and might or might not be //[[CL:Glossary:identical]]// to //sequence//.

The **'':test-not''** //[[CL:Glossary:argument]]// is deprecated.

The functions **[[CL:Functions:delete-if-not]]** and **[[CL:Functions:remove-if-not]]** are deprecated.

\issue{REMF-DESTRUCTION-UNSPECIFIED:X3J13-MAR-89} \issue{REMF-DESTRUCTION-UNSPECIFIED:X3J13-MAR-89} \issue{CONSTANT-MODIFICATION:DISALLOW} \issue{MAPPING-DESTRUCTIVE-INTERACTION:EXPLICITLY-VAGUE} \issue{TEST-NOT-IF-NOT:FLUSH-ALL} \issue{TEST-NOT-IF-NOT:FLUSH-ALL} \issue{SUBSEQ-OUT-OF-BOUNDS} \issue{RANGE-OF-START-AND-END-PARAMETERS:INTEGER-AND-INTEGER-NIL} \issue{RANGE-OF-COUNT-KEYWORD:NIL-OR-INTEGER} \issue{RANGE-OF-COUNT-KEYWORD:NIL-OR-INTEGER}
