\begincom{car, cdr, caar, cadr, cdar, cddr, caaar, caadr, cadar, caddr, cdaar, cdadr, cddar, cdddr, caaaar, caaadr, caadar, caaddr, cadaar, cadadr, caddar, cadddr, cdaaar, cdaadr, cdadar, cdaddr, cddaar, cddadr, cdddar, cddddr}\ftype{Accessor}

====Syntax====

\DefunMultiAccessorWithValues {x} {object} {new-object} {car cdr

caar cadr cdar cddr

caaar caadr cadar caddr cdaar cdadr cddar cdddr

caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr}

====Arguments and Values====

//x// - a //[[CL:Glossary:list]]//.

//object// - an //[[CL:Glossary:object]]//.

//new-object// - an //[[CL:Glossary:object]]//.

====Description====

If //x// is a //[[CL:Glossary:cons]]//, **[[CL:Functions:car]]** returns the //[[CL:Glossary:car]]// of that //[[CL:Glossary:cons]]//. If //x// is **[[CL:Constant Variables:nil]]**, **[[CL:Functions:car]]** returns **[[CL:Constant Variables:nil]]**.

If //x// is a //[[CL:Glossary:cons]]//, **[[CL:Functions:cdr]]** returns the //[[CL:Glossary:cdr]]// of that //[[CL:Glossary:cons]]//. If //x// is **[[CL:Constant Variables:nil]]**, **[[CL:Functions:cdr]]** returns **[[CL:Constant Variables:nil]]**.

//[[CL:Glossary:Functions]]// are provided which perform compositions of up to four **[[CL:Functions:car]]** and **[[CL:Functions:cdr]]** operations. Their //[[CL:Glossary:names]]// consist of a ''C'', followed by two, three, or four occurrences of ''A'' or ''D'', and finally an ''R''. The series of ''A'''s and ''D'''s in each //[[CL:Glossary:function]]//'s //[[CL:Glossary:name]]// is chosen to identify the series of **[[CL:Functions:car]]** and **[[CL:Functions:cdr]]** operations that is performed by the function. The order in which the ''A'''s and ''D'''s appear is the inverse of the order in which the corresponding operations are performed. \Thenextfigure\ defines the relationships precisely.

\tablefigtwo{CAR and CDR variants}{This //[[CL:Glossary:place]]// ''\ldots''}{Is equivalent to this //[[CL:Glossary:place]]// ''\ldots''}{ ''(caar //x//)''&''(car (car //x//))''\cr ''(cadr //x//)''&''(car (cdr //x//))''\cr ''(cdar //x//)''&''(cdr (car //x//))''\cr ''(cddr //x//)''&''(cdr (cdr //x//))''\cr ''(caaar //x//)''&''(car (car (car //x//)))''\cr ''(caadr //x//)''&''(car (car (cdr //x//)))''\cr ''(cadar //x//)''&''(car (cdr (car //x//)))''\cr ''(caddr //x//)''&''(car (cdr (cdr //x//)))''\cr ''(cdaar //x//)''&''(cdr (car (car //x//)))''\cr ''(cdadr //x//)''&''(cdr (car (cdr //x//)))''\cr ''(cddar //x//)''&''(cdr (cdr (car //x//)))''\cr ''(cdddr //x//)''&''(cdr (cdr (cdr //x//)))''\cr ''(caaaar //x//)''&''(car (car (car (car //x//))))''\cr ''(caaadr //x//)''&''(car (car (car (cdr //x//))))''\cr ''(caadar //x//)''&''(car (car (cdr (car //x//))))''\cr ''(caaddr //x//)''&''(car (car (cdr (cdr //x//))))''\cr ''(cadaar //x//)''&''(car (cdr (car (car //x//))))''\cr ''(cadadr //x//)''&''(car (cdr (car (cdr //x//))))''\cr ''(caddar //x//)''&''(car (cdr (cdr (car //x//))))''\cr ''(cadddr //x//)''&''(car (cdr (cdr (cdr //x//))))''\cr ''(cdaaar //x//)''&''(cdr (car (car (car //x//))))''\cr ''(cdaadr //x//)''&''(cdr (car (car (cdr //x//))))''\cr ''(cdadar //x//)''&''(cdr (car (cdr (car //x//))))''\cr ''(cdaddr //x//)''&''(cdr (car (cdr (cdr //x//))))''\cr ''(cddaar //x//)''&''(cdr (cdr (car (car //x//))))''\cr ''(cddadr //x//)''&''(cdr (cdr (car (cdr //x//))))''\cr ''(cdddar //x//)''&''(cdr (cdr (cdr (car //x//))))''\cr ''(cddddr //x//)''&''(cdr (cdr (cdr (cdr //x//))))''\cr }

**[[CL:Macros:setf]]** can also be used with any of these functions to change an existing component of //x//, but **[[CL:Macros:setf]]** will not make new components. So, for example, the //[[CL:Glossary:car]]// of a //[[CL:Glossary:cons]]// can be assigned with **[[CL:Macros:setf]]** of **[[CL:Functions:car]]**, but the //[[CL:Glossary:car]]// of **[[CL:Constant Variables:nil]]** cannot be assigned with **[[CL:Macros:setf]]** of **[[CL:Functions:car]]**. Similarly, the //[[CL:Glossary:car]]// of the //[[CL:Glossary:car]]// of a //[[CL:Glossary:cons]]// whose //[[CL:Glossary:car]]// is a //[[CL:Glossary:cons]]// can be assigned with **[[CL:Macros:setf]]** of **[[CL:Functions:caar]]**, but neither **[[CL:Constant Variables:nil]]** nor a //[[CL:Glossary:cons]]// whose car is **[[CL:Constant Variables:nil]]** can be assigned with **[[CL:Macros:setf]]** of **[[CL:Functions:caar]]**.

The argument //x// is permitted to be a //[[CL:Glossary:dotted list]]// or a //[[CL:Glossary:circular list]]//.

====Examples====

<blockquote> (car nil) → NIL (cdr '(1 . 2)) → 2 (cdr '(1 2)) → (2) (cadr '(1 2)) → 2 (car '(a b c)) → A (cdr '(a b c)) → (B C) </blockquote>

====Affected By====

None.

====Exceptional Situations====

The functions **[[CL:Functions:car]]** and **[[CL:Functions:cdr]]** should signal **[[CL:Types:type-error]]** if they receive an argument which is not a //[[CL:Glossary:list]]//. The other functions (**[[CL:Functions:caar]]**, **[[CL:Functions:cadr]]**, ''\ldots'' **[[CL:Functions:cddddr]]**) should behave for the purpose of error checking as if defined by appropriate calls to **[[CL:Functions:car]]** and **[[CL:Functions:cdr]]**.

====See Also====

**[[CL:Functions:rplaca]]**, **[[CL:Functions:first]]**, **[[CL:Functions:rest]]**

====Notes====

The //[[CL:Glossary:car]]// of a //[[CL:Glossary:cons]]// can also be altered by using **[[CL:Functions:rplaca]]**, and the //[[CL:Glossary:cdr]]// of a //[[CL:Glossary:cons]]// can be altered by using **[[CL:Functions:rplacd]]**.

<blockquote> (car ''x'') ≡ (first ''x'') (cadr ''x'') ≡ (second ''x'') ≡ (car (cdr ''x'')) (caddr ''x'') ≡ (third ''x'') ≡ (car (cdr (cdr ''x''))) (cadddr ''x'') ≡ (fourth ''x'') ≡ (car (cdr (cdr (cdr ''x'')))) </blockquote>

\issue{DOTTED-LIST-ARGUMENTS:CLARIFY}
