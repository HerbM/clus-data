====== Declaration DYNAMIC-EXTENT ======

====Syntax====

\f{(dynamic-extent \interleave{\starparam{var} | \star{\paren{\misc{function} //fn//}}})}

====Arguments====

//var// - a //[[CL:Glossary:variable]]// //[[CL:Glossary:name]]//.

//fn// - a //[[CL:Glossary:function]]// //[[CL:Glossary:name]]//.

====Valid Context====

//[[CL:Glossary:declaration]]//

====Binding Types Affected====

//[[CL:Glossary:variable]]//, //[[CL:Glossary:function]]//

====Description====

In some containing //[[CL:Glossary:form]]//, //F//, this declaration asserts for each \param{var''<sub>i</sub>''} (which need not be bound by //F//), and for each //[[CL:Glossary:value]]// \param{v''<sub>ij</sub>''} that \param{var''<sub>i</sub>''} takes on, and for each //[[CL:Glossary:object]]// \param{x''<sub>ijk</sub>''} that

is an //[[CL:Glossary:otherwise inaccessible part]]// of \param{v''<sub>ij</sub>''} at any time when

\param{v''<sub>ij</sub>''} becomes the value of \param{var''<sub>i</sub>''}, that just after the execution of //F// terminates, \param{x''<sub>ijk</sub>''} is either //[[CL:Glossary:inaccessible]]// (if //F// established a //[[CL:Glossary:binding]]// for \param{var''<sub>i</sub>''}) or still an //[[CL:Glossary:otherwise inaccessible part]]// of the current value of \param{var''<sub>i</sub>''} (if //F// did not establish a //[[CL:Glossary:binding]]// for \param{var''<sub>i</sub>''}).

The same relation holds for each \param{fn''<sub>i</sub>''}, except that the //[[CL:Glossary:bindings]]// are in the //[[CL:Glossary:function]]// //[[CL:Glossary:namespace]]//.

The compiler is permitted to use

this information in any way that is appropriate to the //[[CL:Glossary:implementation]]// and that does not conflict with the semantics of \clisp.

\declref{dynamic-extent} declarations can be //[[CL:Glossary:free declarations]]// or //[[CL:Glossary:bound declarations]]//.

The //vars// and //fns// named in a \declref{dynamic-extent} declaration must not refer to //[[CL:Glossary:symbol macro]]// or //[[CL:Glossary:macro]]// bindings.

====Examples====

Since stack allocation of the initial value entails knowing at the //[[CL:Glossary:object]]//'s creation time that the //[[CL:Glossary:object]]// can be //[[CL:Glossary:stack-allocated]]//, it is not generally useful to make a \declref{dynamic-extent} //[[CL:Glossary:declaration]]// for //[[CL:Glossary:variables]]// which have no lexically apparent initial value. For example, it is probably useful to write:

<blockquote> (defun f () (let ((x (list 1 2 3))) (declare (dynamic-extent x)) ...)) </blockquote>

This would permit those compilers that wish to do so to //[[CL:Glossary:stack allocate]]// the list held by the local variable **[[CL:Functions:x]]**. It is permissible, but in practice probably not as useful, to write:

<blockquote> (defun g (x) (declare (dynamic-extent x)) ...) (defun f () (g (list 1 2 3))) </blockquote>

Most compilers would probably not //[[CL:Glossary:stack allocate]]// the //[[CL:Glossary:argument]]// to **[[CL:Functions:g]]** in **[[CL:Functions:f]]** because it would be a modularity violation for the compiler to assume facts about **[[CL:Functions:g]]** from within **[[CL:Functions:f]]**. Only an implementation that was willing to be responsible for recompiling **[[CL:Functions:f]]** if the definition of **[[CL:Functions:g]]** changed incompatibly could legitimately //[[CL:Glossary:stack allocate]]// the //[[CL:Glossary:list]]// argument to **[[CL:Functions:g]]** in **[[CL:Functions:f]]**.

Here is another example:

<blockquote> (declaim (inline g)) (defun g (x) (declare (dynamic-extent x)) ...) (defun f () (g (list 1 2 3)))

(defun f () (flet ((g (x) (declare (dynamic-extent x)) ...)) (g (list 1 2 3))))

</blockquote> In the previous example, some compilers might determine that optimization was possible and others might not.

A variant of this is the so-called "stack allocated rest list" that can be achieved (in implementations supporting the optimization) by:

<blockquote> (defun f (&rest x) (declare (dynamic-extent x)) ...) </blockquote>

Note that although the initial value of **[[CL:Functions:x]]** is not explicit, the **[[CL:Functions:f]]** function is responsible for assembling the list **[[CL:Functions:x]]** from the passed arguments, so the **[[CL:Functions:f]]** function can be optimized by the compiler to construct a //[[CL:Glossary:stack-allocated]]// list instead of a heap-allocated list in implementations that support such.

In the following example,

<blockquote> (let ((x (list 'a1 'b1 'c1)) (y (cons 'a2 (cons 'b2 (cons 'c2 nil))))) (declare (dynamic-extent x y)) ...) </blockquote> The //[[CL:Glossary:otherwise inaccessible parts]]// of **[[CL:Functions:x]]** are three //[[CL:Glossary:conses]]//, and the //[[CL:Glossary:otherwise inaccessible parts]]// of **[[CL:Functions:y]]** are three other //[[CL:Glossary:conses]]//. None of the symbols **[[CL:Functions:a1]]**, **[[CL:Functions:b1]]**, **[[CL:Functions:c1]]**, **[[CL:Functions:a2]]**, **[[CL:Functions:b2]]**, **[[CL:Functions:c2]]**, or **[[CL:Constant Variables:nil]]** is an //[[CL:Glossary:otherwise inaccessible part]]// of **[[CL:Functions:x]]** or **[[CL:Functions:y]]** because each is //[[CL:Glossary:interned]]// and hence //[[CL:Glossary:accessible]]// by the //[[CL:Glossary:package]]// (or //[[CL:Glossary:packages]]//) in which it is //[[CL:Glossary:interned]]//. However, if a freshly allocated //[[CL:Glossary:uninterned]]// //[[CL:Glossary:symbol]]// had been used, it would have been an //[[CL:Glossary:otherwise inaccessible part]]// of the //[[CL:Glossary:list]]// which contained it.

<blockquote> ;; In this example, the implementation is permitted to //[[CL:Glossary:stack allocate]]// ;; the list that is bound to X. (let ((x (list 1 2 3))) (declare (dynamic-extent x)) (print x) :done)
▷ (1 2 3) → :DONE

;; In this example, the list to be bound to L can be //[[CL:Glossary:stack-allocated]]//. (defun zap (x y z) (do ((l (list x y z) (cdr l))) ((null l)) (declare (dynamic-extent l)) (prin1 (car l)))) → ZAP (zap 1 2 3)
▷ 123 → NIL

;; Some implementations might open-code LIST-ALL-PACKAGES in a way ;; that permits using //[[CL:Glossary:stack allocation]]// of the list to be bound to L. (do ((l (list-all-packages) (cdr l))) ((null l)) (declare (dynamic-extent l)) (let ((name (package-name (car l)))) (when (string-search "COMMON-LISP" name) (print name))))
▷ "COMMON-LISP"
▷ "COMMON-LISP-USER" → NIL

;; Some implementations might have the ability to //[[CL:Glossary:stack allocate]]// ;; rest lists. A declaration such as the following should be a cue ;; to such implementations that stack-allocation of the rest list ;; would be desirable. (defun add (&rest x) (declare (dynamic-extent x)) (apply #'+ x)) → ADD (add 1 2 3) → 6

(defun zap (n m) ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N). ;; It may be slow, but with a good compiler at least it ;; doesn't waste much heap storage. :-} (let ((a (make-array n))) (declare (dynamic-extent a)) (dotimes (i n) (declare (dynamic-extent i)) ([[CL:Macros:setf]] (aref a i) (random (+ i 1)))) (aref a m))) → ZAP (< (zap 5 3) 3) → //[[CL:Glossary:true]]// </blockquote>

The following are in error, since the value of **[[CL:Functions:x]]** is used outside of its //[[CL:Glossary:extent]]//:

<blockquote> (length (list (let ((x (list 1 2 3))) ; Invalid (declare (dynamic-extent x)) x)))

(progn (let ((x (list 1 2 3))) ; Invalid (declare (dynamic-extent x)) x) nil) </blockquote>

====See Also====

\misc{declare}

====Notes====

The most common optimization is to //[[CL:Glossary:stack allocate]]// the initial value of the //[[CL:Glossary:object|objects]]// named by the //vars//.

It is permissible for an implementation to simply ignore this declaration.

\issue{DYNAMIC-EXTENT:NEW-DECLARATION} \issue{DYNAMIC-EXTENT-FUNCTION:EXTEND} \issue{MACRO-DECLARATIONS:MAKE-EXPLICIT}
