\begincom{logand, logandc1, logandc2, logeqv, logior, lognand, lognor, lognot, logorc1, logorc2, logxor}\ftype{Function}

====Syntax====

**logand** //''&rest'' integers// → //result-integer// **logandc1** //integer-1 integer-2// → //result-integer// **logandc2** //integer-1 integer-2// → //result-integer// **logeqv** //''&rest'' integers// → //result-integer// **logior** //''&rest'' integers// → //result-integer// **lognand ** //integer-1 integer-2// → //result-integer// **lognor ** //integer-1 integer-2// → //result-integer// **lognot** //integer// → //result-integer// **logorc1 ** //integer-1 integer-2// → //result-integer// **logorc2 ** //integer-1 integer-2// → //result-integer// **logxor** //''&rest'' integers// → //result-integer//

====Arguments and Values====

//integers// - //[[CL:Glossary:integers]]//.

//integer// - an //[[CL:Glossary:integer]]//.

//integer-1// - an //[[CL:Glossary:integer]]//.

//integer-2// - an //[[CL:Glossary:integer]]//.

//result-integer// - an //[[CL:Glossary:integer]]//.

====Description====

The //[[CL:Glossary:functions]]// **[[CL:Functions:logandc1]]**, **[[CL:Functions:logandc2]]**, **[[CL:Functions:logand]]**, **[[CL:Functions:logeqv]]**, **[[CL:Functions:logior]]**, **[[CL:Functions:lognand]]**, **[[CL:Functions:lognor]]**, **[[CL:Functions:lognot]]**, **[[CL:Functions:logorc1]]**, **[[CL:Functions:logorc2]]**, and **[[CL:Functions:logxor]]** perform bit-wise logical operations on their //[[CL:Glossary:arguments]]//, that are treated as if they were binary.

\Thenextfigure\ lists the meaning of each of the //[[CL:Glossary:functions]]//. Where an `identity' is shown, it indicates the //[[CL:Glossary:value]]// //[[CL:Glossary:yielded]]// by the //[[CL:Glossary:function]]// when no //[[CL:Glossary:arguments]]// are supplied.

\tablefigthree{Bit-wise Logical Operations on Integers} {Function}{Identity}{Operation performed}{ **[[CL:Functions:logandc1]]** & --- & and complement of //integer-1// with //integer-2// \cr **[[CL:Functions:logandc2]]** & --- & and //integer-1// with complement of //integer-2// \cr **[[CL:Functions:logand]]** & ''-1'' & and \cr **[[CL:Functions:logeqv]]** & ''-1'' & equivalence (exclusive nor) \cr **[[CL:Functions:logior]]** & ''0'' & inclusive or \cr **[[CL:Functions:lognand]]** & --- & complement of //integer-1// and //integer-2// \cr **[[CL:Functions:lognor]]** & --- & complement of //integer-1// or //integer-2// \cr **[[CL:Functions:lognot]]** & --- & complement \cr **[[CL:Functions:logorc1]]** & --- & or complement of //integer-1// with //integer-2// \cr **[[CL:Functions:logorc2]]** & --- & or //integer-1// with complement of //integer-2// \cr **[[CL:Functions:logxor]]** & ''0'' & exclusive or \cr }

Negative //integers// are treated as if they were in two's-complement notation.

====Examples====

<blockquote> (logior 1 2 4 8) → 15 (logxor 1 3 7 15) → 10 (logeqv) → -1 (logand 16 31) → 16 (lognot 0) → -1 (lognot 1) → -2 (lognot -1) → 0 (lognot (1+ (lognot 1000))) → 999

;;; In the following example, m is a mask. For each bit in ;;; the mask that is a 1, the corresponding bits in x and y are ;;; exchanged. For each bit in the mask that is a 0, the ;;; corresponding bits of x and y are left unchanged. (flet ((show (m x y) (format t "~ m x y))) (let ((m #o007750) (x #o452576) (y #o317407)) (show m x y) (let ((z (logand (logxor x y) m))) ([[CL:Macros:defparameter]] x (logxor z x)) ([[CL:Macros:defparameter]] y (logxor z y)) (show m x y))))
▷ m = #o007750
▷ x = #o452576
▷ y = #o317407
▷
▷ m = #o007750
▷ x = #o457426
▷ y = #o312557 → NIL </blockquote>

====Side Effects====

None.

====Affected By====

None.

====Exceptional Situations====

Should signal **[[CL:Types:type-error]]** if any argument is not an //[[CL:Glossary:integer]]//.

====See Also====

**[[CL:Functions:boole]]**

====Notes====

''(logbitp //k// -1)'' returns //[[CL:Glossary:true]]// for all values of //k//.

Because the following functions are not associative, they take exactly two arguments rather than any number of arguments.

<blockquote> (lognand //n1// //n2//) ≡ (lognot (logand //n1// //n2//)) (lognor //n1// //n2//) ≡ (lognot (logior //n1// //n2//)) (logandc1 //n1// //n2//) ≡ (logand (lognot //n1//) //n2//) (logandc2 //n1// //n2//) ≡ (logand //n1// (lognot //n2//)) (logiorc1 //n1// //n2//) ≡ (logior (lognot //n1//) //n2//) (logiorc2 //n1// //n2//) ≡ (logior //n1// (lognot //n2//)) (logbitp //j// (lognot //x//)) ≡ (not (logbitp //j// //x//)) </blockquote>

