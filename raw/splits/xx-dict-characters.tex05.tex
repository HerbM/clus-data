\begincom{char=, char/=, char<, char>, char<=, char>=, char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, char-not-lessp}\ftype{Function}

====Syntax====

\DefunMultiWithValues {''&rest'' characters''+''} {generalized-boolean} {\entry{{char''=''}} \entry{{char''/=''}} \entry{{char''<''}} \entry{{char''>''}} \entry{{char''<=''}} \entry{{char''>=''}} \noalign{\vskip 5pt} char-equal char-not-equal char-lessp char-greaterp char-not-greaterp char-not-lessp}

====Arguments and Values====

//character// - a //[[CL:Glossary:character]]//.

//generalized-boolean// - a //[[CL:Glossary:generalized boolean]]//.

====Description====

These predicates compare //[[CL:Glossary:characters]]//.

**[[CL:Functions:char=]]** returns //[[CL:Glossary:true]]// if all //characters// are the //[[CL:Glossary:same]]//; otherwise, it returns //[[CL:Glossary:false]]//.

If two //characters// differ in any //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attributes]]//, then they are not **[[CL:Functions:char=]]**.

**[[CL:Functions:char/=]]** returns //[[CL:Glossary:true]]// if all //characters// are different; otherwise, it returns //[[CL:Glossary:false]]//.

**[[CL:Functions:char<]]** returns //[[CL:Glossary:true]]// if the //characters// are monotonically increasing; otherwise, it returns //[[CL:Glossary:false]]//.

If two //[[CL:Glossary:characters]]// have //[[CL:Glossary:identical]]// //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attributes]]//, then their ordering by **[[CL:Functions:char<]]** is consistent with the numerical ordering by the predicate ''<'' on their //[[CL:Glossary:codes]]//.

**[[CL:Functions:char>]]** returns //[[CL:Glossary:true]]// if the //characters// are monotonically decreasing; otherwise, it returns //[[CL:Glossary:false]]//.

If two //[[CL:Glossary:characters]]// have //[[CL:Glossary:identical]]// //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attributes]]//, then their ordering by **[[CL:Functions:char>]]** is consistent with the numerical ordering by the predicate ''>'' on their //[[CL:Glossary:codes]]//.

**[[CL:Functions:char<=]]** returns //[[CL:Glossary:true]]// if the //characters// are monotonically nondecreasing; otherwise, it returns //[[CL:Glossary:false]]//.

If two //[[CL:Glossary:characters]]// have //[[CL:Glossary:identical]]// //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attributes]]//, then their ordering by **[[CL:Functions:char<=]]** is consistent with the numerical ordering by the predicate ''<='' on their //[[CL:Glossary:codes]]//.


**[[CL:Functions:char>=]]** returns //[[CL:Glossary:true]]// if the //characters// are monotonically nonincreasing; otherwise, it returns //[[CL:Glossary:false]]//.

If two //[[CL:Glossary:characters]]// have //[[CL:Glossary:identical]]// //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attributes]]//, then their ordering by **[[CL:Functions:char>=]]** is consistent with the numerical ordering by the predicate ''>='' on their //[[CL:Glossary:codes]]//.

**[[CL:Functions:char-equal]]**, **[[CL:Functions:char-not-equal]]**, **[[CL:Functions:char-lessp]]**, **[[CL:Functions:char-greaterp]]**, **[[CL:Functions:char-not-greaterp]]**, and **[[CL:Functions:char-not-lessp]]** are similar to **[[CL:Functions:char=]]**, **[[CL:Functions:char/=]]**, **[[CL:Functions:char<]]**, **[[CL:Functions:char>]]**, **[[CL:Functions:char<=]]**, **[[CL:Functions:char>=]]**, respectively, except that they ignore differences in //[[CL:Glossary:case]]// and

might have an //[[CL:Glossary:implementation-defined]]// behavior for //[[CL:Glossary:non-simple]]// //[[CL:Glossary:characters]]//.

For example, an //[[CL:Glossary:implementation]]// might define that **[[CL:Functions:char-equal]]**, ''etc.'' ignore certain //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attributes]]//. The effect, if any, of each //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attribute]]// upon these functions must be specified as part of the definition of that //[[CL:Glossary:attribute]]//.

====Examples====

<blockquote> (char= #\\d #\\d) → //[[CL:Glossary:true]]// (char= #\\A #\\a) → //[[CL:Glossary:false]]// (char= #\\d #\\x) → //[[CL:Glossary:false]]// (char= #\\d #\\D) → //[[CL:Glossary:false]]// (char/= #\\d #\\d) → //[[CL:Glossary:false]]// (char/= #\\d #\\x) → //[[CL:Glossary:true]]// (char/= #\\d #\\D) → //[[CL:Glossary:true]]// (char= #\\d #\\d #\\d #\\d) → //[[CL:Glossary:true]]// (char/= #\\d #\\d #\\d #\\d) → //[[CL:Glossary:false]]// (char= #\\d #\\d #\\x #\\d) → //[[CL:Glossary:false]]// (char/= #\\d #\\d #\\x #\\d) → //[[CL:Glossary:false]]// (char= #\\d #\\y #\\x #\\c) → //[[CL:Glossary:false]]// (char/= #\\d #\\y #\\x #\\c) → //[[CL:Glossary:true]]// (char= #\\d #\\c #\\d) → //[[CL:Glossary:false]]// (char/= #\\d #\\c #\\d) → //[[CL:Glossary:false]]// (char< #\\d #\\x) → //[[CL:Glossary:true]]// (char<= #\\d #\\x) → //[[CL:Glossary:true]]// (char< #\\d #\\d) → //[[CL:Glossary:false]]// (char<= #\\d #\\d) → //[[CL:Glossary:true]]// (char< #\\a #\\e #\\y #\\z) → //[[CL:Glossary:true]]// (char<= #\\a #\\e #\\y #\\z) → //[[CL:Glossary:true]]// (char< #\\a #\\e #\\e #\\y) → //[[CL:Glossary:false]]// (char<= #\\a #\\e #\\e #\\y) → //[[CL:Glossary:true]]// (char> #\\e #\\d) → //[[CL:Glossary:true]]// (char>= #\\e #\\d) → //[[CL:Glossary:true]]// (char> #\\d #\\c #\\b #\\a) → //[[CL:Glossary:true]]// (char>= #\\d #\\c #\\b #\\a) → //[[CL:Glossary:true]]// (char> #\\d #\\d #\\c #\\a) → //[[CL:Glossary:false]]// (char>= #\\d #\\d #\\c #\\a) → //[[CL:Glossary:true]]// (char> #\\e #\\d #\\b #\\c #\\a) → //[[CL:Glossary:false]]// (char>= #\\e #\\d #\\b #\\c #\\a) → //[[CL:Glossary:false]]// (char> #\\z #\\A) → //[[CL:Glossary:implementation-dependent]]// (char> #\\Z #\\a) → //[[CL:Glossary:implementation-dependent]]// (char-equal #\\A #\\a) → //[[CL:Glossary:true]]// (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp) → (#\\A #\\a #\\b #\\B #\\c #\\C) (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<) → (#\\A #\\B #\\C #\\a #\\b #\\c) ;Implementation A → (#\\a #\\b #\\c #\\A #\\B #\\C) ;Implementation B → (#\\a #\\A #\\b #\\B #\\c #\\C) ;Implementation C → (#\\A #\\a #\\B #\\b #\\C #\\c) ;Implementation D → (#\\A #\\B #\\a #\\b #\\C #\\c) ;Implementation E </blockquote>

====Affected By====

None.

====Exceptional Situations====

\Shouldcheckplus{character}

====See Also====

{\secref\CharacterSyntax}, {\secref\ImplementationDefinedScripts}

====Notes====

If characters differ in their //[[CL:Glossary:code]]// //[[CL:Glossary:attribute]]// or any //[[CL:Glossary:implementation-defined]]// //[[CL:Glossary:attribute]]//, they are considered to be different by **[[CL:Functions:char=]]**.

There is no requirement that ''(eq c1 c2)'' be true merely because ''(char= c1 c2)'' is //[[CL:Glossary:true]]//. While **[[CL:Functions:eq]]** can distinguish two //[[CL:Glossary:characters]]// that **[[CL:Functions:char=]]** does not, it is distinguishing them not as //[[CL:Glossary:characters]]//, but in some sense on the basis of a lower level implementation characteristic. If ''(eq c1 c2)'' is //[[CL:Glossary:true]]//, then ''(char= c1 c2)'' is also true. **[[CL:Functions:eql]]** and **[[CL:Functions:equal]]** compare //[[CL:Glossary:characters]]// in the same way that **[[CL:Functions:char=]]** does.

The manner in which //[[CL:Glossary:case]]// is used by **[[CL:Functions:char-equal]]**, **[[CL:Functions:char-not-equal]]**, **[[CL:Functions:char-lessp]]**, **[[CL:Functions:char-greaterp]]**, **[[CL:Functions:char-not-greaterp]]**, and **[[CL:Functions:char-not-lessp]]** implies an ordering for //[[CL:Glossary:standard characters]]// such that ''A=a'', ''B=b'', and so on, up to ''Z=z'', and furthermore either ''9<A'' or ''Z<0''.

\issue{CHARACTER-PROPOSAL:2-1-1} \issue{CHARACTER-PROPOSAL:2-1-1} \issue{CHARACTER-PROPOSAL:2-1-1} \issue{CHARACTER-PROPOSAL:2-1-1} \issue{CHARACTER-PROPOSAL:2-1-1} \issue{CHARACTER-PROPOSAL:2-1-1} \issue{CHARACTER-PROPOSAL:2-1-1}
