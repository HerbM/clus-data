====== Function DELETE-PACKAGE ======

====Syntax====

**delete-package** //package// → //generalized-boolean//

====Arguments and Values====

//package// - a //[[CL:Glossary:package designator]]//.

//generalized-boolean// - a //[[CL:Glossary:generalized boolean]]//.

====Description====

**[[CL:Functions:delete-package]]** deletes //package// from all package system data structures.

If the operation is successful, **[[CL:Functions:delete-package]]** returns true, otherwise **[[CL:Constant Variables:nil]]**.

The effect of **[[CL:Functions:delete-package]]** is that the name and nicknames of //package// cease to be recognized package names. The package //[[CL:Glossary:object]]// is still a //[[CL:Glossary:package]]// (i.e. **[[CL:Functions:packagep]]** is //[[CL:Glossary:true]]// of it) but **[[CL:Functions:package-name]]** returns **[[CL:Constant Variables:nil]]**.

The consequences of deleting \thepackage{common-lisp} or \thepackage{keyword} are undefined.

The consequences of invoking any other package operation on //package// once it has been deleted are unspecified. In particular, the consequences of invoking **[[CL:Functions:find-symbol]]**, **[[CL:Functions:intern]]** and other functions that look for a symbol name in a //[[CL:Glossary:package]]// are unspecified if they are called with **[[CL:Variables:*package*]]** bound to the deleted //package// or with the deleted //package// as an argument.

If //package// is a //[[CL:Glossary:package]]// //[[CL:Glossary:object]]// that has already been deleted, **[[CL:Functions:delete-package]]** immediately returns **[[CL:Constant Variables:nil]]**.

After this operation completes, the

//[[CL:Glossary:home package]]// of any //[[CL:Glossary:symbol]]// whose //[[CL:Glossary:home package]]//

had previously been //package//

is

//[[CL:Glossary:implementation-dependent]]//. Except for this, //[[CL:Glossary:symbols]]// //[[CL:Glossary:accessible]]// in //package// are not modified in any other way; //[[CL:Glossary:symbols]]// whose //[[CL:Glossary:home package]]// is not //package// remain unchanged.

====Examples====

<blockquote> ([[CL:Macros:defparameter]] *foo-package* (make-package "FOO" :use nil)) ([[CL:Macros:defparameter]] *foo-symbol* (intern "FOO" *foo-package*)) (export *foo-symbol* *foo-package*)

([[CL:Macros:defparameter]] *bar-package* (make-package "BAR" :use '("FOO"))) ([[CL:Macros:defparameter]] *bar-symbol* (intern "BAR" *bar-package*)) (export *foo-symbol* *bar-package*) (export *bar-symbol* *bar-package*)

([[CL:Macros:defparameter]] *baz-package* (make-package "BAZ" :use '("BAR")))

(symbol-package *foo-symbol*) → #<PACKAGE "FOO"> (symbol-package *bar-symbol*) → #<PACKAGE "BAR">

(prin1-to-string *foo-symbol*) → "FOO:FOO" (prin1-to-string *bar-symbol*) → "BAR:BAR"

(find-symbol "FOO" *bar-package*) → FOO:FOO, :EXTERNAL

(find-symbol "FOO" *baz-package*) → FOO:FOO, :INHERITED (find-symbol "BAR" *baz-package*) → BAR:BAR, :INHERITED

(packagep *foo-package*) → //[[CL:Glossary:true]]// (packagep *bar-package*) → //[[CL:Glossary:true]]// (packagep *baz-package*) → //[[CL:Glossary:true]]//

(package-name *foo-package*) → "FOO" (package-name *bar-package*) → "BAR" (package-name *baz-package*) → "BAZ"

(package-use-list *foo-package*) → () (package-use-list *bar-package*) → (#<PACKAGE "FOO">) (package-use-list *baz-package*) → (#<PACKAGE "BAR">)

(package-used-by-list *foo-package*) → (#<PACKAGE "BAR">) (package-used-by-list *bar-package*) → (#<PACKAGE "BAZ">) (package-used-by-list *baz-package*) → ()

(delete-package *bar-package*)
▷ Error: Package BAZ uses package BAR.
▷ If continued, BAZ will be made to unuse-package BAR,
▷ and then BAR will be deleted.
▷ Type :CONTINUE to continue.
▷ Debug> \IN{:CONTINUE} → T

(symbol-package *foo-symbol*) → #<PACKAGE "FOO"> (symbol-package *bar-symbol*) is unspecified

(prin1-to-string *foo-symbol*) → "FOO:FOO" (prin1-to-string *bar-symbol*) is unspecified

(find-symbol "FOO" *bar-package*) is unspecified

(find-symbol "FOO" *baz-package*) → NIL, NIL (find-symbol "BAR" *baz-package*) → NIL, NIL

(packagep *foo-package*) → T (packagep *bar-package*) → T (packagep *baz-package*) → T

(package-name *foo-package*) → "FOO" (package-name *bar-package*) → NIL (package-name *baz-package*) → "BAZ"

(package-use-list *foo-package*) → () (package-use-list *bar-package*) is unspecified (package-use-list *baz-package*) → ()

(package-used-by-list *foo-package*) → () (package-used-by-list *bar-package*) is unspecified (package-used-by-list *baz-package*) → () </blockquote>

====Affected By====

None.

====Exceptional Situations====

If the //package// //[[CL:Glossary:designator]]// is a //[[CL:Glossary:name]]// that does not currently name a //[[CL:Glossary:package]]//, a //[[CL:Glossary:correctable]]// error of type **[[CL:Types:package-error]]** is signaled. If correction is attempted, no deletion action is attempted; instead, **[[CL:Functions:delete-package]]** immediately returns **[[CL:Constant Variables:nil]]**.

If //package// is used by other //[[CL:Glossary:packages]]//, a //[[CL:Glossary:correctable]]// error of type **[[CL:Types:package-error]]** is signaled. If correction is attempted, **[[CL:Functions:unuse-package]]** is effectively called to remove any dependencies, causing //package//'s //[[CL:Glossary:external symbols]]// to cease being //[[CL:Glossary:accessible]]// to those //[[CL:Glossary:packages]]// that use //package//. **[[CL:Functions:delete-package]]** then deletes //package// just as it would have had there been no //[[CL:Glossary:packages]]// that used it.

====See Also====

**[[CL:Functions:unuse-package]]**

====Notes====

None.




\issue{PACKAGE-DELETION:NEW-FUNCTION} \issue{PACKAGE-FUNCTION-CONSISTENCY:MORE-PERMISSIVE}
