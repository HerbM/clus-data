====== Macro CASE, CCASE, ECASE ======

====Syntax====

\DefmacWithValues case {keyform \stardown{normal-clause} \brac{\down{otherwise-clause}}} {\starparam{result}} \DefmacWithValues ccase {keyplace \stardown{normal-clause}} {\starparam{result}} \DefmacWithValues ecase {keyform \stardown{normal-clause}} {\starparam{result}}

\auxbnf{normal-clause}{\paren{keys \starparam{form}}} \auxbnf{otherwise-clause}{\paren{{otherwise | t} \starparam{form}}} \auxbnf{clause}{normal-clause | otherwise-clause} \idxref{otherwise}\idxref{t}

====Arguments and Values====

//keyform// - a //[[CL:Glossary:form]]//; evaluated to produce a //test-key//.

//keyplace// - a //[[CL:Glossary:form]]//; evaluated initially to produce a //test-key//. Possibly also used later as a //[[CL:Glossary:place]]// if no //keys// match.

//test-key// - an object produced by evaluating //keyform// or //keyplace//.

//keys// - a //[[CL:Glossary:designator]]// for a //[[CL:Glossary:list]]// of //[[CL:Glossary:object|objects]]//. In the case of **[[CL:Macros:case]]**, the //[[CL:Glossary:symbols]]// \t\ and \misc{otherwise} may not be used as the //keys// //[[CL:Glossary:designator]]//. To refer to these //[[CL:Glossary:symbols]]// by themselves as //keys//, the designators ''(t)'' and ''(otherwise)'', respectively, must be used instead.

//forms// - an //[[CL:Glossary:implicit progn]]//.

//results// - the //[[CL:Glossary:value|values]]// returned by the //forms// in the matching //clause//.

====Description====

These //[[CL:Glossary:macro|macros]]// allow the conditional execution of a body of //forms// in a //clause// that is selected by matching the //test-key// on the basis of its identity.

The //keyform// or //keyplace// is //[[CL:Glossary:evaluated]]// to produce the //test-key//.

Each of the //normal-clauses// is then considered in turn. If the //test-key// is the //[[CL:Glossary:same]]// as any //[[CL:Glossary:key]]// for that //clause//, the //forms// in that //clause// are //evaluated// as an //[[CL:Glossary:implicit progn]]//, and the //[[CL:Glossary:value|values]]// it returns are returned as the value of the **[[CL:Macros:case]]**, **[[CL:Macros:ccase]]**, or **[[CL:Macros:ecase]]** //[[CL:Glossary:form]]//.

These //[[CL:Glossary:macro|macros]]// differ only in their //[[CL:Glossary:behavior]]// when no //normal-clause// matches; specifically:

\beginlist

\itemitem{**[[CL:Macros:case]]**}

If no //normal-clause// matches, and there is an //otherwise-clause//, then that //otherwise-clause// automatically matches; the //forms// in that //clause// are //evaluated// as an //[[CL:Glossary:implicit progn]]//, and the //[[CL:Glossary:value|values]]// it returns are returned as the value of the **[[CL:Macros:case]]**.

If there is no //otherwise-clause//, **[[CL:Macros:case]]** returns **[[CL:Constant Variables:nil]]**.

\itemitem{**[[CL:Macros:ccase]]**}

If no //normal-clause// matches, a //[[CL:Glossary:correctable]]// //[[CL:Glossary:error]]// of type **[[CL:Types:type-error]]** is signaled. The offending datum is the //test-key// and the expected type is //[[CL:Glossary:type equivalent]]// to ''(member //key1// //key2// ...)''. \Therestart{store-value} can be used to correct the error.

If \therestart{store-value} is invoked, its //[[CL:Glossary:argument]]// becomes the new //test-key//, and is stored in //keyplace// as if by ''(setf //keyplace// //test-key//)''. Then **[[CL:Macros:ccase]]** starts over, considering each //clause// anew.

\reviewer{Barmar: Will it prompt for multiple values if keyplace is a VALUES general ref?}

The subforms of //keyplace// might be evaluated again if none of the cases holds.

\itemitem{**[[CL:Macros:ecase]]**}

If no //normal-clause// matches, a //[[CL:Glossary:non-correctable]]// //[[CL:Glossary:error]]// of type **[[CL:Types:type-error]]** is signaled. The offending datum is the //test-key// and the expected type is //[[CL:Glossary:type equivalent]]// to ''(member //key1// //key2// ...)''.

Note that in contrast with **[[CL:Macros:ccase]]**, the caller of **[[CL:Macros:ecase]]** may rely on the fact that **[[CL:Macros:ecase]]** does not return if a //normal-clause// does not match.

\endlist

====Examples====

<blockquote> (dolist (k '(1 2 3 :four #\\v () t 'other)) (format t "~S " (case k ((1 2) 'clause1) (3 'clause2) (nil 'no-keys-so-never-seen) ((nil) 'nilslot) ((:four #\\v) 'clause4) ((t) 'tslot) (otherwise 'others))))
▷ CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS → NIL (defun add-em (x) (apply #'+ (mapcar #'decode x))) → ADD-EM (defun decode (x) (ccase x ((i uno) 1) ((ii dos) 2) ((iii tres) 3) ((iv cuatro) 4))) → DECODE (add-em '(uno iii)) → 4 (add-em '(uno iiii))
▷ Error: The value of X, IIII, is not I, UNO, II, DOS, III,
▷ TRES, IV, or CUATRO.
▷ 1: Supply a value to use instead.
▷ 2: Return to Lisp Toplevel.
▷ Debug> \IN{:CONTINUE 1}
▷ Value to evaluate and use for X: \IN{'IV} → 5 </blockquote>

====Side Effects====

The debugger might be entered. If \therestart{store-value} is invoked, the //[[CL:Glossary:value]]// of //keyplace// might be changed.

====Affected By====

**[[CL:Macros:ccase]]** and **[[CL:Macros:ecase]]**, since they might signal an error, are potentially affected by existing //handlers// and **[[CL:Variables:*debug-io*]]**.

====Exceptional Situations====

**[[CL:Macros:ccase]]** and **[[CL:Macros:ecase]]** signal an error of type **[[CL:Types:type-error]]** if no //normal-clause// matches.

====See Also====

**[[CL:Macros:cond]]**, **[[CL:Macros:typecase]]**, **[[CL:Macros:setf]]**, {\secref\GeneralizedReference}

====Notes====

<blockquote> (case //test-key// \star{\curly{((\starparam{key}) \starparam{form})}}) ≡ (let ((#1=#:g0001 //test-key//)) (cond \star{\curly{((member #1# '(\starparam{key})) \starparam{form})}})) </blockquote>

The specific error message used by **[[CL:Macros:ecase]]** and **[[CL:Macros:ccase]]** can vary between implementations. In situations where control of the specific wording of the error message is important, it is better to use **[[CL:Macros:case]]** with an //otherwise-clause// that explicitly signals an error with an appropriate message.

