====== Macro WITH-HASH-TABLE-ITERATOR ======

====Syntax====
  * with-hash-table-iterator //(name hash-table) declaration''*'' form''*''// â†’//result''*''//

====Arguments and Values====
  * //name// - a name suitable for the first argument to **[[CL:Special Operators:macrolet]]**.
  * //hash-table// - a //[[CL:Glossary:form]]//, evaluated once, that should produce a //[[CL:Glossary:hash table]]//.
  * //declaration// - a **[[CL:Symbols:declare]]** //[[CL:Glossary:expression]]//; not evaluated.
  * //forms// - an //[[CL:Glossary:implicit progn]]//.
  * //results// - the //[[CL:Glossary:values]]// returned by //forms//.

====Description====
Within the lexical scope of the body, //name// is defined via **[[CL:Special Operators:macrolet]]** such that successive invocations of ''(//name//)'' return the items, one by one, from the //[[CL:Glossary:hash table]]// that is obtained by evaluating //hash-table// only once.

An invocation ''(//name//)'' returns three values as follows:

\beginlist

\itemitem{1.} A //[[CL:Glossary:generalized boolean]]// that is //[[CL:Glossary:true]]// if an entry is returned. 
\itemitem{2.} The key from the //hash-table// entry. 
\itemitem{3.} The value from the //hash-table// entry. 

\endlist After all entries have been returned by successive invocations of ''(//name//)'', then only one value is returned, namely **[[CL:Constant Variables:nil]]**.


It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the **[[CL:Macros:with-hash-table-iterator]]** //[[CL:Glossary:form]]// such as by returning some //[[CL:Glossary:closure]]// over the invocation //[[CL:Glossary:form]]//.

Any number of invocations of **[[CL:Macros:with-hash-table-iterator]]** can be nested, and the body of the innermost one can invoke all of the locally //[[CL:Glossary:established]]// //[[CL:Glossary:macros]]//, provided all of those //[[CL:Glossary:macros]]// have //[[CL:Glossary:distinct]]// names.

====Examples====
The following function should return \t\ on any //[[CL:Glossary:hash table]]//, and signal an error if the usage of **[[CL:Macros:with-hash-table-iterator]]** does not agree with the corresponding usage of **[[CL:Functions:maphash]]**.

<blockquote> (defun test-hash-table-iterator (hash-table) (let ((all-entries '()) (generated-entries '()) (unique (list nil))) (maphash #'(lambda (key value) (push (list key value) all-entries)) hash-table) (with-hash-table-iterator (generator-fn hash-table) (loop (multiple-value-bind (more? key value) (generator-fn) (unless more? (return)) (unless (eql value (gethash key hash-table unique)) (error "Key ~S not found for value ~S" key value)) (push (list key value) generated-entries)))) (unless (= (length all-entries) (length generated-entries) (length (union all-entries generated-entries :key #'car :test (hash-table-test hash-table)))) (error "Generated entries and Maphash entries don't correspond")) t)) </blockquote>

The following could be an acceptable definition of **[[CL:Functions:maphash]]**, implemented by **[[CL:Macros:with-hash-table-iterator]]**.

<blockquote> (defun maphash (function hash-table) (with-hash-table-iterator (next-entry hash-table) (loop (multiple-value-bind (more key value) (next-entry) (unless more (return nil)) (funcall function key value))))) </blockquote>

====Side Effects====
None.

====Affected By====
None.

====Exceptional Situations====
The consequences are undefined if the local function named //name// //[[CL:Glossary:established]]// by **[[CL:Macros:with-hash-table-iterator]]** is called after it has returned //[[CL:Glossary:false]]// as its //[[CL:Glossary:primary value]]//.

====See Also====
  * {\secref\TraversalRules}

====Notes====
None.

\issue{DECLS-AND-DOC} \issue{HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER} \issue{MAPPING-DESTRUCTIVE-INTERACTION:EXPLICITLY-VAGUE}
