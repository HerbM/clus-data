====== Function COMPUTE-RESTARTS ======

====Syntax====

**compute-restarts** //''&optional'' condition// → //restarts//

====Arguments and Values====

//condition// - a //[[CL:Glossary:condition]]// //[[CL:Glossary:object]]//, or **[[CL:Constant Variables:nil]]**.

//restarts// - a //[[CL:Glossary:list]]// of //[[CL:Glossary:restarts]]//.

====Description====

**[[CL:Functions:compute-restarts]]** uses the dynamic state of the program to compute a //[[CL:Glossary:list]]// of the //[[CL:Glossary:restarts]]// which are currently active.

The resulting //[[CL:Glossary:list]]// is ordered so that the innermost (more-recently established) restarts are nearer the head of the //[[CL:Glossary:list]]//.

When //condition// is //[[CL:Glossary:non-nil]]//, only those //[[CL:Glossary:restarts]]// are considered that are either explicitly associated with that //condition//, or not associated with any //[[CL:Glossary:condition]]//; that is, the excluded //[[CL:Glossary:restarts]]// are those that are associated with a non-empty set of //[[CL:Glossary:conditions]]// of which the given //condition// is not an //[[CL:Glossary:element]]//. If //condition// is **[[CL:Constant Variables:nil]]**, all //[[CL:Glossary:restarts]]// are considered.

**[[CL:Functions:compute-restarts]]** returns all

//[[CL:Glossary:applicable restarts]]//, including anonymous ones, even if some of them have the same name as others and would therefore not be found by **[[CL:Functions:find-restart]]** when given a //[[CL:Glossary:symbol]]// argument.

Implementations are permitted, but not required, to return //[[CL:Glossary:distinct]]// //[[CL:Glossary:lists]]// from repeated calls to **[[CL:Functions:compute-restarts]]** while in the same dynamic environment. The consequences are undefined if the //[[CL:Glossary:list]]// returned by **[[CL:Functions:compute-restarts]]** is every modified.

====Examples====

<blockquote> ;; One possible way in which an interactive debugger might present ;; restarts to the user. (defun invoke-a-restart () (let ((restarts (compute-restarts))) (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r)) (format t "~&~D: ~A~ (let ((n nil) (k (length restarts))) (loop (when (and (typep n 'integer) (>= n 0) (< n k)) (return t)) (format t "~&Option: ") ([[CL:Macros:defparameter]] n (read)) (fresh-line)) (invoke-restart-interactively (nth n restarts)))))

(restart-case (invoke-a-restart) (one () 1) (two () 2) (nil () :report "Who knows?" 'anonymous) (one () 'I) (two () 'II))
▷ 0: ONE
▷ 1: TWO
▷ 2: Who knows?
▷ 3: ONE
▷ 4: TWO
▷ 5: Return to Lisp Toplevel.
▷ Option: \IN{4} → II

;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS ;; also returns information about any system-supplied restarts, such as ;; the "Return to Lisp Toplevel" restart offered above.

</blockquote>


====Side Effects====

None.

====Affected By====

Existing restarts.

====Exceptional Situations====

None.

====See Also====

**[[CL:Functions:find-restart]]**, **[[CL:Functions:invoke-restart]]**, **[[CL:Functions:restart-bind]]**

====Notes====

None.

\issue{CONDITION-RESTARTS:PERMIT-ASSOCIATION} \issue{CONDITION-RESTARTS:PERMIT-ASSOCIATION} \issue{CONDITION-RESTARTS:PERMIT-ASSOCIATION}
