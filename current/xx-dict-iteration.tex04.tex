====== Macro LOOP ======

====Syntax====
The "simple" **[[CL:Macros:loop]]** //[[CL:Glossary:form]]//:

\DefmacWithValues loop {\starparam{compound-form}} {\starparam{result}}

The "extended" **[[CL:Macros:loop]]** //[[CL:Glossary:form]]//:

\DefmacWithValues loop {\brac{name-clause} \stardown{variable-clause} \stardown{main-clause}} {\starparam{result}}

name-clause ::= named //name//
variable-clause ::= with-clause | initial-final | for-as-clause
with-clause ::= with //var1// [//type-spec//] [''='' //form1//] {and //var2// [//type-spec//] [''='' //form2//]}''*''
main-clause ::= unconditional | accumulation | conditional | termination-test | initial-final
initial-final ::= initially compound-form''+'' | finally compound-form''+''
unconditional ::= {do | doing} compound-form''+'' | return {//form// | it}
accumulation ::= list-accumulation | numeric-accumulation
list-accumulation ::= {collect | collecting | append | appending | nconc | nconcing} {//form// | it} [into //simple-var//]
numeric-accumulation ::= {count | counting | sum | summing | maximize | maximizing | minimize | minimizing} {//form// | it} [into //simple-var//] [//type-spec//]
conditional ::= {if | when | unless} //form// selectable-clause {and selectable-clause}''*'' [else selectable-clause {and selectable-clause}''*''] [end]

selectable-clause ::= unconditional | accumulation | conditional
termination-test ::= while //form// | until //form// | repeat //form// | always //form// | never //form// | thereis //form//
for-as-clause ::= {for | as} for-as-subclause {and for-as-subclause}''*''
for-as-subclause ::= for-as-arithmetic | for-as-in-list | for-as-on-list | for-as-equals-then |for-as-across | for-as-hash | for-as-package
for-as-arithmetic ::= //var// [//type-spec//] for-as-arithmetic-subclause
for-as-arithmetic-subclause ::= arithmetic-up | arithmetic-downto | arithmetic-downfrom
arithmetic-up ::= [[{from | upfrom} //form1// | {to | upto | below} //form2// |  //form3//]]''+''
arithmetic-downto ::= \one{\curly{from //form1//}} | \one{\curly{\curly{downto | above} //form2//}} |  //form3//
arithmetic-downfrom ::= \one{\curly{downfrom //form1//}} | \curly{to | downto | above} //form2// |  //form3//
for-as-in-list ::= //var// [//type-spec//] in //form1// \brac{by //step-fun//}
for-as-on-list ::= //var// [//type-spec//] on //form1// \brac{by //step-fun//}
for-as-equals-then ::= //var// [//type-spec//] ''='' //form1// \brac{then //form2//}
for-as-across ::= //var// [//type-spec//] across //vector//
for-as-hash ::= //var// [//type-spec//] being \curly{each | the} \lcurly\curly{hash-key | hash-keys} \curly{in | of} //hash-table// \xcurly\brac{using \paren{hash-value //other-var//}} | \xcurly\curly{hash-value | hash-values} \curly{in | of} //hash-table// \xcurly\brac{using \paren{hash-key //other-var//}}\rcurly
for-as-package ::= //var// [//type-spec//] being \curly{each | the} \lcurlysymbol | symbols |\xcurlypresent-symbol | present-symbols |\xcurlyexternal-symbol | external-symbols\rcurly \brac{\curly{in | of} //package//}
type-spec ::= simple-type-spec | destructured-type-spec
simple-type-spec ::= \declref{fixnum} | \declref{float} | \declref{t} | \declref{nil}
destructured-type-spec ::= of-type //d-type-spec//
d-type-spec ::= //type-specifier// | ''(//d-type-spec// . //d-type-spec//)''
var ::= d-var-spec
var1 ::= d-var-spec
var2 ::= d-var-spec
other-var ::= d-var-spec
d-var-spec ::= //simple-var// | **[[CL:Constant Variables:nil]]** | (d-var-spec ''.'' d-var-spec)

====Arguments and Values====
  * //compound-form// - a //[[CL:Glossary:compound form]]//.
  * //name// - a //[[CL:Glossary:symbol]]//.
  * //simple-var// - a //[[CL:Glossary:symbol]]// (a //[[CL:Glossary:variable]]// name).
  * //form//, //form1//, //form2//, //form3// - a //[[CL:Glossary:form]]//.
  * //step-fun// - a //[[CL:Glossary:form]]// that evaluates to a //[[CL:Glossary:function]]// of one //[[CL:Glossary:argument]]//.
  * //vector// - a //[[CL:Glossary:form]]// that evaluates to a //[[CL:Glossary:vector]]//.
  * //hash-table// - a //[[CL:Glossary:form]]// that evaluates to a //[[CL:Glossary:hash table]]//.
  * //package// - a //[[CL:Glossary:form]]// that evaluates to a //[[CL:Glossary:package designator]]//.
  * //type-specifier// - a //[[CL:Glossary:type specifier]]//. This might be either an //[[CL:Glossary:atomic type specifier]]// or a //[[CL:Glossary:compound type specifier]]//, which introduces some additional complications to proper parsing in the face of destructuring; for further information, see section {\secref\DestructuringLOOPVars}.
  * //result// - an //[[CL:Glossary:object]]//.

====Description====

For details, see section {\secref\LoopFacility}.

====Examples====

<blockquote> ;; An example of the simple form of LOOP. (defun sqrt-advisor () (loop (format t "~&Number: ") (let ((n (parse-integer (read-line) :junk-allowed t))) (when (not n) (return)) (format t "~&The square root of ~D is ~D.~ → SQRT-ADVISOR (sqrt-advisor)
▷ Number: \IN{5\CRLF}
▷ The square root of 5 is 2.236068.
▷ Number: \IN{4\CRLF}
▷ The square root of 4 is 2.
▷ Number: \IN{done\CRLF} → NIL

;; An example of the extended form of LOOP. (defun square-advisor () (loop as n = (progn (format t "~&Number: ") (parse-integer (read-line) :junk-allowed t)) while n do (format t "~&The square of ~D is ~D.~ → SQUARE-ADVISOR (square-advisor)
▷ Number: \IN{4\CRLF}
▷ The square of 4 is 16.
▷ Number: \IN{23\CRLF}
▷ The square of 23 is 529.
▷ Number: \IN{done\CRLF} → NIL

;; Another example of the extended form of LOOP. (loop for n from 1 to 10 when (oddp n) collect n) → (1 3 5 7 9) </blockquote>

====Affected By====

None.

====Exceptional Situations====

None.

====See Also====

**[[CL:Macros:do]]**, **[[CL:Macros:dolist]]**, **[[CL:Macros:dotimes]]**, **[[CL:Macros:return]]**, **[[CL:Special Operators:go]]**, **[[CL:Special Operators:throw]]**, {\secref\DestructuringLOOPVars}

====Notes====

Except that **[[CL:Macros:loop-finish]]** cannot be used within a simple **[[CL:Functions:loop]]** //[[CL:Glossary:form]]//, a simple **[[CL:Macros:loop]]** //[[CL:Glossary:form]]// is related to an extended **[[CL:Macros:loop]]** //[[CL:Glossary:form]]// in the following way:

<blockquote> (loop \starparam{compound-form}) ≡ (loop do \starparam{compound-form}) </blockquote>

\issue{LOOP-SYNTAX-OVERHAUL:REPAIR} \issue{LOOP-MISCELLANEOUS-REPAIRS:FIX}
