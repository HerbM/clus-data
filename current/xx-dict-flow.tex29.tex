====== Special Operator UNWIND-PROTECT ======

====Syntax====

\DefspecWithValues unwind-protect {//protected-form// \starparam{cleanup-form}} {\starparam{result}}

====Arguments and Values====

//protected-form// - a //[[CL:Glossary:form]]//.

//cleanup-form// - a //[[CL:Glossary:form]]//.

//results// - the //[[CL:Glossary:value|values]]// of the //[[CL:Glossary:protected-form]]//.

====Description====

**[[CL:Special Operators:unwind-protect]]** evaluates //protected-form// and guarantees that //cleanup-forms// are executed before **[[CL:Special Operators:unwind-protect]]** exits, whether it terminates normally or is aborted by a control transfer of some kind. **[[CL:Special Operators:unwind-protect]]** is intended to be used to make sure that certain side effects take place after the evaluation of //protected-form//.

If a //[[CL:Glossary:non-local exit]]// occurs during execution of //cleanup-forms//, no special action is taken. The //cleanup-forms// of **[[CL:Special Operators:unwind-protect]]** are not protected by that **[[CL:Special Operators:unwind-protect]]**.

**[[CL:Special Operators:unwind-protect]]** protects against all attempts to exit from //protected-form//, including **[[CL:Special Operators:go]]**, **[[CL:Macros:handler-case]]**, **[[CL:Macros:ignore-errors]]**, **[[CL:Macros:restart-case]]**, **[[CL:Special Operators:return-from]]**, **[[CL:Special Operators:throw]]**, and **[[CL:Macros:with-simple-restart]]**.

Undoing of //[[CL:Glossary:handler]]// and //[[CL:Glossary:restart]]// //[[CL:Glossary:binding|bindings]]// during an exit happens in parallel with the undoing of the bindings of //[[CL:Glossary:dynamic variables]]// and **[[CL:Special Operators:catch]]** tags, in the reverse order in which they were established. The effect of this is that //cleanup-form// sees the same //[[CL:Glossary:handler]]// and //[[CL:Glossary:restart]]// //[[CL:Glossary:binding|bindings]]//, as well as //[[CL:Glossary:dynamic variable]]// //[[CL:Glossary:binding|bindings]]// and **[[CL:Special Operators:catch]]** tags, as were visible when the **[[CL:Special Operators:unwind-protect]]** was entered.

====Examples==== <blockquote> (tagbody (let ((x 3)) (unwind-protect (if (numberp x) (go out)) (print x))) out ...) </blockquote> When **[[CL:Special Operators:go]]** is executed, the call to **[[CL:Functions:print]]** is executed first, and then the transfer of control to the tag ''out'' is completed.

<blockquote> (defun dummy-function (x) ([[CL:Macros:defparameter]] state 'running) (unless (numberp x) (throw 'abort 'not-a-number)) ([[CL:Macros:defparameter]] state (1+ x))) → DUMMY-FUNCTION (catch 'abort (dummy-function 1)) → 2 state → 2 (catch 'abort (dummy-function 'trash)) → NOT-A-NUMBER state → RUNNING (catch 'abort (unwind-protect (dummy-function 'trash) ([[CL:Macros:defparameter]] state 'aborted))) → NOT-A-NUMBER state → ABORTED </blockquote>

The following code is not correct:

<blockquote> (unwind-protect (progn (incf *access-count*) (perform-access)) (decf *access-count*)) </blockquote> If an exit occurs before completion of **[[CL:Macros:incf]]**, the **[[CL:Macros:decf]]** //[[CL:Glossary:form]]// is executed anyway, resulting in an incorrect value for ''*access-count*''. The correct way to code this is as follows:

<blockquote> (let ((old-count *access-count*)) (unwind-protect (progn (incf *access-count*) (perform-access)) ([[CL:Macros:defparameter]] *access-count* old-count))) </blockquote>


<blockquote> ;;; The following returns 2. (block nil (unwind-protect (return 1) (return 2)))

;;; The following has undefined consequences. (block a (block b (unwind-protect (return-from a 1) (return-from b 2))))

;;; The following returns 2. (catch nil (unwind-protect (throw nil 1) (throw nil 2)))

;;; The following has undefined consequences because the catch of B is ;;; passed over by the first THROW, hence portable programs must assume ;;; its dynamic extent is terminated. The binding of the catch tag is not ;;; yet disestablished and therefore it is the target of the second throw. (catch 'a (catch 'b (unwind-protect (throw 'a 1) (throw 'b 2))))

;;; The following prints "The inner catch returns :SECOND-THROW" ;;; and then returns :OUTER-CATCH. (catch 'foo (format t "The inner catch returns ~s.~ (catch 'foo (unwind-protect (throw 'foo :first-throw) (throw 'foo :second-throw)))) :outer-catch)


;;; The following returns 10. The inner CATCH of A is passed over, but ;;; because that CATCH is disestablished before the THROW to A is executed, ;;; it isn't seen. (catch 'a (catch 'b (unwind-protect (1+ (catch 'a (throw 'b 1))) (throw 'a 10))))


;;; The following has undefined consequences because the extent of ;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...) ;;; commences. (catch 'foo (catch 'bar (unwind-protect (throw 'foo 3) (throw 'bar 4) (print 'xxx))))


;;; The following returns 4; XXX is not printed. ;;; The (THROW 'FOO ...) has no effect on the scope of the BAR ;;; catch tag or the extent of the (CATCH 'BAR ...) exit. (catch 'bar (catch 'foo (unwind-protect (throw 'foo 3) (throw 'bar 4) (print 'xxx))))


;;; The following prints 5. (block nil (let ((x 5)) (declare (special x)) (unwind-protect (return) (print x)))) </blockquote>


====Affected By====

None.

====Exceptional Situations====

None.

====See Also====

**[[CL:Special Operators:catch]]**, **[[CL:Special Operators:go]]**, **[[CL:Macros:handler-case]]**, **[[CL:Macros:restart-case]]**, **[[CL:Macros:return]]**, **[[CL:Special Operators:return-from]]**, **[[CL:Special Operators:throw]]**, {\secref\Evaluation}

====Notes====

None.

\issue{EXIT-EXTENT-AND-CONDITION-SYSTEM:LIKE-DYNAMIC-BINDINGS} \issue{EXIT-EXTENT:MINIMAL}
